{
  "hash": "2f614d0f3e51018f614d80c516642aef",
  "result": {
    "markdown": "---\ntitle: \"Aquiring Data via an API\"\ndescription: |\n    Part 2 of a mini-series on aquiring data from the web, focusing on data aquisition via APIs. \ndate: \"2022-12-13\"\ncategories:\n  - data science\n  - data acquisition\n  - tutorial\ncode-fold: false\nimage: apis-and-httr.png\nimage-alt: The text APIs and httr, written on a black hexagon. \nimage-cap: \"{rvest}\"\ndraft: false\nfreeze: true\nappendix-style: plain #(default, plain, none)\nbibliography: ../library.bib\n---\n\n\n\n## Aquiring Data: Part 2 - Using APIs\n\n::: medium_right\n<img style = \"border-radius: 10%;\" src=\"apis-and-httr.png\" alt=\"The text APIs and httr, written on a black hexagon.\">\n:::\n\nYou can't always rely on tidy, tabular data to land on your desk. Sometimes you are going to have to go out and gather data for yourself.\n\nI'm not suggesting you will need to do this manually, but you will likely need to get data from the internet that's been made publicly or privately available to you. \n\nThis might be information from a webpage that you gather yourself, or data shared with you by a collaborator using an API.\n\nIn this second blog post we will cover the basics of obtaining data via an API. This material draws together the [Introduction to APIs](https://zapier.com/learn/apis/) book by Brian Cooksey and the [DIY web data](https://stat545.com/diy-web-data.html#interacting-with-an-api) section of STAT545 at the University of British Columbia.\n\n## Why do I need to know about APIs? \n\n> An API, or application programming interface, is a set of rules that allows different software applications to communicate with each other.\n\nAs a data scientist, you will often need to access data that is stored on remote servers or in cloud-based services. APIs provide a convenient way for data scientists to programmatically retrieve this data, without having to manually download data sets or and process them locally on their own computer.\n\nThis has multiple benefits including automation and standardisation of data sharing.\n\n- **Automation:** It is much faster for a machine to process a data request than a human. Having a machine handling data requests also scales much better as either the number or the complexity of data requests grows. Additionally, there is a lower risk of introducing human error. For example, a human might accidentally share the wrong data, which can have serious legal repercussions. \n\n- **Standardisation:** Having a machine process data requests requires the format of these requests and the associated responses to be standardised. This allows data sharing and retrieval to become a reproducible and programmatic aspect of our work.\n\n\n## What is an API?\n\nSo then, if APIs are so great, what exactly are they? \n\nIn human-to-human communication, the set of rules governing acceptable behaviour is known as etiquette. Depending on when or where you live, social etiquette can be rather strict. The rules for computer-to-computer communication take this to a whole new level, because with machines there can be no room left for interpretation. \n\nThe set of rules governing interactions between computers or programmes is known as a __protocol__. \n\nAPIs provide a standard protocol for different programs to interact with one another. This makes it easier for developers to build complex systems by leveraging the functionality of existing services and platforms. The benefits of working in a standardised and modular way apply equally well to sharing data as they do to writing code or organising files. \n\nThere are two sides to communication and when _machines_ communicate these are known as the __server__ and the __client__. \n\n::: medium_right\n<img style = \"border-radius: 10%;\" src=\"server-schematic.png\" alt=\"Schematic diagram representing a computer server. Text above reads 'Servers: don't fear a computer with no screen'.\">\n:::\n\nServers can seem intimidating, because unlike your laptop or mobile phone they don't have their own input and output devices; they have no keyboard, no monitor, and no a mouse. Despite this, servers are just regular computers that are designed to store data and run programmes. Servers don't have their own input or output devices because they are intended to be used _remotely_, via another computer. There is no need for a screen or a mouse if the user is miles away. Nothing scary going on here!\n\nPeople often find clients much less intimidating - they are simply any other computer or application that might contact the sever. \n\n\n## HTTP \n\nThis leads us one step further down the rabbit-hole. An API is a protocol that defines the rules of how applications communicate with one another. But how does this communication happen? \n\nHTTP (Hypertext Transfer Protocol) is the dominant mode communication on the World Wide Web. You can see the secure version of HTTP, HTTPS, at the start of most web addresses up at the top of your browser. For example:\n\n```{.http}\nhttps://www.zakvarty.com/blog\n```\n\nHTTP is the foundation of data communication on the web and is used to transfer files (such as text, images, and videos) between web servers and clients.\n\n::: medium_left\n<img style = \"border-radius: 10%;\" src=\"request-response.png\" alt=\"Schematic diagram showing a request being sent from a client to a server, which returns a response.\">\n:::\n\nTo understand HTTP communications, I find it helpful to imagine the client and the server as being a customer and a waiter at a restaurant. The client makes some request to the server, which then tries to comply before giving a response. The server might respond to confirm that the request was completed successfully. Alternatively, the server might respond with an error message, which is (hopefully) informative about why the request could not be completed. \n\nThis request-response model is the basis for HTTP, the communication system used by the majority of APIs.  \n\n## HTTP Requests \n\nAn HTML request consists of: \n\n- Uniform Resource Locator (URL) [unique identifier for a thing] \n- Method [tells server the type of action requested by client]\n- Headers [meta-information about request, e.g. device type]\n- Body [Data the client wants to send to the server] \n\n::: medium_right\n<img style = \"border-radius: 10%;\" src=\"html-request.png\" alt=\"Schematic diagram showing the structure of an HTML request, composed of: a URL, method, headers and body.\">\n:::\n\n### URL \nThe URL in a HTTP request specifies where that request is going to be made, for example `http://example.com`.\n\n### Method\nThe action that the client wants to take is indicated by a set of well-defined methods or HTTP verbs. The most common HTTP verbs are `GET`, `POST`, `PUT`, `PATCH`, and `DELETE`.\n\nThe `GET` verb is used to retrieve a resource from the server, such as a web page or an image. The `POST` verb is used to send data to the server, such as when submitting a form or uploading a file. The `PUT` verb is used to replace a resource on the server with a new one, while the `PATCH` verb is used to update a resource on the server without replacing it entirely. Finally, the `DELETE` verb is used to delete a resource from the server.\n\nIn addition to these common HTTP verbs, there are also several less frequently used verbs. These are used for specialized purposes, such as requesting only the headers of a resource, or testing the connectivity between the client and the server.\n\n### Header\nThe request headers contain meta-information about the request. This is where information about the device type would be included within the request.\n\n### Body \nFinally, the body of the request contains the data that the client is providing to the server.\n\n\n## HTTP Responses \n\nWhen the server receives a request it will attempt to fulfil it and then send a response back to the client. \n\n::: medium_left\n<img style = \"border-radius: 10%;\" src=\"html-response.png\" alt=\"Schematic diagram showing the structure of an HTML response, composed of: a status code, headers and body.\">\n:::\n\nA response has a similar structure to a request apart from: \n\n- responses __do not have__ a URL,\n- responses __do not have__ a method,\n- responses __have__ a status code. \n\n### Status Codes \n\nThe status code is a 3 digit number, each of which has a specific meaning. Some common error codes that you might (already have) come across are: \n\n- 200: Success,\n- 404: Page not found (all 400s are errors),\n- 503: Page down.\n\nIn a data science context, a successful response will return the requested data within the data field. This will most likely be given in JSON or XML format. \n\n## Authentication \n\nNow that we know _how_ applications communicate, you might ask how we can control who has access to the API and what types of request they can make. This can be done by the server setting appropriate permissions for each client. But then how does the server verify that the client is really who is claims to be?\n\n__Authentication__ is a way to ensure that only authorized clients are able to access an API. This is typically done by the server requiring each client to provide some secret information that uniquely identifies them, whenever they make requests to the API. This information allows the API server to validate the authenticity this user before it authorises the request. \n\n### Basic Authentication\n\nThere are various ways to implement API authentication. \n\nBasic authentication involves each legitimate client having a username and password. An encrypted version of these is included in the `Authorization` header of the HTTP request. If the hear matches with the server's records then the request is processed. If not, then a special status code (401) is returned to the client. \n\nBasic authentication is dangerous because it does not put any restrictions on what a client can do once they are authorised. Additional, individualised restrictions can be added by using an alternative authentication scheme. \n\n### API Key Authentication\n\nAn API key is long, random string of letters and numbers that is assigned to each authorised user. An API key is distinct from the user's password and keys are typically issued by the service that provides an API. Using keys rather than basic authentication allows the API provider to track and limit the usage of their API. \n\nFor example, a provider may issue a unique API key to each developer or organization that wants to use the API. The provider can then limit access to certain data. They could also limit the number of requests that each key can make in a given time period or prevent access to certain administrative functions, like changing passwords or deleting accounts.\n\nUnlike Basic Authentication, there is no standard way of a client sharing a key with the server. Depending on the API this might be in the `Authorization` field of the header, at the end of the URL (`http://example.com?api_key=my_secret_key`), or within the body of the data. \n\n\n## API wrappers\n\nWe've learned a lot about how the internet works. Fortunately, a lot of the time we won't have to worry about all of that new information other than for debugging purposes. \n\nIn the best case scenario, a very kind developer has written a \"wrapper\" function for the API. These wrappers are functions in R that will construct the HTML request for you. If you are particularly lucky, the API wrapper will also format the response for you, converting it from XML or JSON back into an R object that is ready for immediate use. \n\n\n## `{geonames}` wrapper\n\n[rOpenSci](https://ropensci.org/) has a curated list of many wrappers for accessing scientific data using R. We will focus on the [GeoNames API](https://www.geonames.org/), which gives open access to a geographical database. To access this data, we will use wrapper functions provided by the `{geonames}` [package](https://docs.ropensci.org/geonames/). \n\nThe aim here is to illustrate the important steps of getting started with a new API. \n\n### Set up \n\nBefore we can get any data from the GeoNames API, we first need to do a little bit of set up.\n\n1. Install and load `{geonames}` from CRAN\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#install.packages(\"geonames\")\nlibrary(geonames)\n```\n:::\n\n\n2. Create a user account for the GeoNames API\n\n<img style = \"border-radius: 0%;\" src=\"sign-up.png\" alt=\"Screenshot of the GeoNames login page. Example text has been added in the fields to create a new user account.\">\n\n3. Activate the account (see activation email)\n\n<img style = \"border-radius: 0%;\" src=\"confirmation-email.png\" alt=\"Screenshot of the GeoNames confirmation email, which gives a link to click in order to confirm the new account.\"> \n\n\n4. Enable the free web services for your GeoNames account by logging in at this [link](http://www.geonames.org/enablefreewebservice).\n\n\n5. Tell R your credentials for GeoNames. \n\n::: {.callout-warning}\nWe could use the following code to tell R our credentials, but we absolutely should not.\n\n\n::: {.cell}\n\n```{.r .cell-code}\noptions(geonamesUsername=\"example_username\")\n```\n:::\n\n\nThis would save our username as an environment variable, but it _also_ puts our API credentials directly into the script. If we share the script with our others (internally, externally or publicly) we would be sharing our credentials too. Not good!\n:::\n\n## Keep it Secret, Keep it Safe\n\nThe solution to this problem is to add our credentials as environment variables in our `.Rprofile` rather than in this script. The `.Rprofile` is an R script that is run at the start of every session. IT can be created and edited directly, but can also be created and edited from within R. \n\nTo make/open your `.Rprofile` use the `edit_r_profile()` function from the `{usethis}` package. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(usethis)\nusethis::edit_r_profile()\n```\n:::\n\n\nWithin this file, add `options(geonamesUsername=\"example_username\")` on a new line, remembering to replace `example_username` with your own GeoNames username.  \n\nThe final step is to __check this this file ends with a blank line__, save it and restart R. Then we are all set to start using `{geonames}`. \n\nThis set up procedure is indicative of most API wrappers, but of course the details will vary between each API. This is why good documentation is important! \n\n## Using `{geonames}` \n\nGeoNames has a whole host of [different geo-datasets](http://www.geonames.org/export/ws-overview.html) that you can explore. \nAs a first example, let's get all of the geo-tagged wikipedia articles that are within 1km of Imperial College London. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nimperial_coords <- list(lat = 51.49876, lon = -0.1749)\nsearch_radius_km <- 1\n\nimperial_neighbours <- geonames::GNfindNearbyWikipedia(\n  lat = imperial_coords$lat,\n  lng = imperial_coords$lon, \n  radius = search_radius_km,\n  lang = \"en\",                # english language articles\n  maxRows = 500              # maximum number of results to return \n)\n```\n:::\n\n\nLooking at the structure of `imperial_neighbours` we can see that it is a data frame with one row per geo-tagged wikipedia article. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(imperial_neighbours)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'data.frame':\t204 obs. of  13 variables:\n $ summary     : chr  \"The Department of Mechanical Engineering is responsible for teaching and research in mechanical engineering at \"| __truncated__ \"Imperial College Business School is a global business school located in London. The business school was opened \"| __truncated__ \"Exhibition Road is a street in South Kensington, London which is home to several major museums and academic est\"| __truncated__ \"Imperial College School of Medicine (ICSM) is the medical school of Imperial College London in England, and one\"| __truncated__ ...\n $ elevation   : chr  \"20\" \"18\" \"19\" \"24\" ...\n $ feature     : chr  \"edu\" \"edu\" \"landmark\" \"edu\" ...\n $ lng         : chr  \"-0.1746\" \"-0.1748\" \"-0.17425\" \"-0.1757\" ...\n $ distance    : chr  \"0.0335\" \"0.0494\" \"0.0508\" \"0.0558\" ...\n $ rank        : chr  \"81\" \"91\" \"90\" \"96\" ...\n $ lang        : chr  \"en\" \"en\" \"en\" \"en\" ...\n $ title       : chr  \"Department of Mechanical Engineering, Imperial College London\" \"Imperial College Business School\" \"Exhibition Road\" \"Imperial College School of Medicine\" ...\n $ lat         : chr  \"51.498524\" \"51.4992\" \"51.4989722222222\" \"51.4987\" ...\n $ wikipediaUrl: chr  \"en.wikipedia.org/wiki/Department_of_Mechanical_Engineering%2C_Imperial_College_London\" \"en.wikipedia.org/wiki/Imperial_College_Business_School\" \"en.wikipedia.org/wiki/Exhibition_Road\" \"en.wikipedia.org/wiki/Imperial_College_School_of_Medicine\" ...\n $ countryCode : chr  NA \"AE\" NA \"GB\" ...\n $ thumbnailImg: chr  NA NA NA NA ...\n $ geoNameId   : chr  NA NA NA NA ...\n```\n:::\n:::\n\n\nTo confirm we have the correct location we can inspect the title of the first five neighbours.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nimperial_neighbours$title[1:5]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Department of Mechanical Engineering, Imperial College London\"             \n[2] \"Imperial College Business School\"                                          \n[3] \"Exhibition Road\"                                                           \n[4] \"Imperial College School of Medicine\"                                       \n[5] \"Department of Civil and Environmental Engineering, Imperial College London\"\n```\n:::\n:::\n\n\nNothing too surprising here, mainly departments of the college and Exhibition Road, which runs along one side of the campus. These sorts of check are important - I initially forgot the minus in the longitude and was getting results in East London!  \n\n## What if there is no wrapper? \n\nIf there is not a wrapper function, we can still access APIs fairly easilty using the `{httr}` package.\n\nWe will look at an example using [OMDb](http://www.omdbapi.com/), which is an open source version of [IMDb](https://www.imdb.com/), to get information about the movie Mean Girls.  \n\nTo use the OMDB API you will once again need to [request a free API key](http://www.omdbapi.com/apikey.aspx), follow a verification link and add your API key to your `.Rprofile`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Add this to .Rprofile, pasting in your own API key\noptions(OMDB_API_Key = \"PASTE YOUR KEY HERE\")\n```\n:::\n\n\nYou can then restart R and safely access your API key from within your R session. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load your API key into the current R session,\nombd_api_key <- getOption(\"OMDB_API_Key\")\n```\n:::\n\n\nUsing the documentation for the API, requests have URLs of the following form, where terms in angular brackets should be replaced by you. \n\n```\nhttp://www.omdbapi.com/?t=<TITLE>&y=<YEAR>&plot=<LENGTH>&r=<FORMAT>&apikey=<API_KEY>\n```\n\nWith a little bit of effort, we can write a function that composes this type of request URL for us. We will using the `{glue}` package to help us join strings together. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' Compose search requests for the OMBD API\n#'\n#' @param title String defining title to search for. Words are separated by \"+\".\n#' @param year String defining release year to search for\n#' @param plot String defining whether \"short\" or \"full\" plot is returned\n#' @param format String defining return format. One of \"json\" or \"xml\"\n#' @param api_key String defining your OMDb API key.\n#'\n#' @return String giving a OMBD search request URL\n#'\n#' @examples \n#' omdb_url(\"mean+girls\", \"2004\", \"short\", \"json\", getOption(OMBD_API_Key))\n#' \nomdb_url <- function(title, year, plot, format, api_key) {\n  glue::glue(\"http://www.omdbapi.com/?t={title}&y={year}&plot={plot}&r={format}&apikey={api_key}\")\n}\n```\n:::\n\n\nRunning the example we get: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean_girls_request <- omdb_url(\n  title = \"mean+girls\",\n  year =  \"2004\",\n  plot = \"short\",\n  format =  \"json\",\n  api_key =  getOption(\"OMDB_API_Key\"))\n```\n:::\n\n\nWe can then use the `{httr}` package to construct our request and store the response we get.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresponse <- httr::GET(url = mean_girls_request)\nhttr::status_code(response)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 200\n```\n:::\n:::\n\n\nThankfully it was a success! If you get a 401 error code here, check that you have clicked the activation link for your API key. \n\nThe full structure of the response is quite complicated, but we can easily extract the requested data using `content()` \n\n\n::: {.cell}\n\n```{.r .cell-code}\nhttr::content(response)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$Title\n[1] \"Mean Girls\"\n\n$Year\n[1] \"2004\"\n\n$Rated\n[1] \"PG-13\"\n\n$Released\n[1] \"30 Apr 2004\"\n\n$Runtime\n[1] \"97 min\"\n\n$Genre\n[1] \"Comedy\"\n\n$Director\n[1] \"Mark Waters\"\n\n$Writer\n[1] \"Rosalind Wiseman, Tina Fey\"\n\n$Actors\n[1] \"Lindsay Lohan, Jonathan Bennett, Rachel McAdams\"\n\n$Plot\n[1] \"Cady Heron is a hit with The Plastics, the A-list girl clique at her new school, until she makes the mistake of falling for Aaron Samuels, the ex-boyfriend of alpha Plastic Regina George.\"\n\n$Language\n[1] \"English, German, Vietnamese, Swahili\"\n\n$Country\n[1] \"United States, Canada\"\n\n$Awards\n[1] \"7 wins & 25 nominations\"\n\n$Poster\n[1] \"https://m.media-amazon.com/images/M/MV5BMjE1MDQ4MjI1OV5BMl5BanBnXkFtZTcwNzcwODAzMw@@._V1_SX300.jpg\"\n\n$Ratings\n$Ratings[[1]]\n$Ratings[[1]]$Source\n[1] \"Internet Movie Database\"\n\n$Ratings[[1]]$Value\n[1] \"7.1/10\"\n\n\n$Ratings[[2]]\n$Ratings[[2]]$Source\n[1] \"Rotten Tomatoes\"\n\n$Ratings[[2]]$Value\n[1] \"84%\"\n\n\n$Ratings[[3]]\n$Ratings[[3]]$Source\n[1] \"Metacritic\"\n\n$Ratings[[3]]$Value\n[1] \"66/100\"\n\n\n\n$Metascore\n[1] \"66\"\n\n$imdbRating\n[1] \"7.1\"\n\n$imdbVotes\n[1] \"385,107\"\n\n$imdbID\n[1] \"tt0377092\"\n\n$Type\n[1] \"movie\"\n\n$DVD\n[1] \"21 Sep 2004\"\n\n$BoxOffice\n[1] \"$86,058,055\"\n\n$Production\n[1] \"N/A\"\n\n$Website\n[1] \"N/A\"\n\n$Response\n[1] \"True\"\n```\n:::\n:::\n\n\n## Wrapping up \n\nWe have learned a bit more about how the internet works, the benefits of using an API to share data and how to request data from Open APIs.\n\nWhen obtaining data from the internet it's vital that you keep your credentials safe, and that don't do more work than is needed. \n\n- Keep your API keys out of your code. Store them in your `.Rprofile` (and make sure this is not under version control!)\n\n- Scraping is always a last resort. Is there an API already? \n- Writing your own code to access an API can be more painful than necessary. \n- Don't repeat other people, if a suitable wrapper exists then use it. \n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}