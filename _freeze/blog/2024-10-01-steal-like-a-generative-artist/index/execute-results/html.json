{
  "hash": "3f11b45610de3ac14a0e9d5d6da2b35d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Steal like a generative artist\"\ndescription: |\n    A first forray into generative art\ndate: \"2024-10-01\"\ncategories:\n  - R\n  - Generative Art\n  - Events\nimage: pyramid-header-1812-2.png\nimage-alt: \"Grid of pyramids viewed from above each with one random side coloured in the zvplot colour palette.\"\ndraft: false\nfreeze: true\nappendix-style: plain #(default, plain, none)\nbibliography: ../library.bib\ncitation: true\n---\n\n::: {.cell}\n\n:::\n\n\n## Making a new banner image \n\nI recently realised that my banner image on twitter was a bit dated and that I didn't even have one on LinkedIn. To fix that, I'm going to to follow up on the session that [Nicola Rennie](https://nrennie.rbind.io/) ran at the RSS pre-conference workshop and get started with generative art. (Slides from the session are available at this [link](https://nrennie.rbind.io/rss-2024-generative-art/))\n\nI've done lots of plotting of simulated data before, which I guess technically counts as generative art, but this is my first attempt at making plots for purely ~\\*aesthetic\\*~ purposes. One of the main takeaways for me from Nicola's talk was to [steal like an artist](https://bookshop.org/p/books/steal-like-an-artist-10-things-nobody-told-you-about-being-creative-austin-kleon/6862462). In a nutshell, a great way to learn any new creative skill is to copy and riff on what other people have done already. When developing generative art skills it can be helpful to:\n\n- start by using tools that other people have made to create generative art,\n- recreate or adapt those tools for yourself,\n- take inspiration for generative designs from more traditional art forms,\n- recreate designs or patterns from objects in the world around you. \n\nIn that spirit, I'll be recreating and adapting one of her title slide artworks. \n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](./generative-art-slide-nrennie.png){fig-align='center' fig-alt='Section slide from Nicola Rennie. The slide features a tiled design of multi-coloured squares, split into triangles to give the appearance of pyramids viewed from above. The order of the colours and the location of the pyramid peaks are chosen randomly.' width=70%}\n:::\n:::\n\n\n## Scoping the project\n\n**The parameters** set by the user for this artwork would likely include: the number of rows and columns of \"pyramids\", the four colours to be used or the sides of the pyramids and perhaps the spacing between the pyramids relative to their base size.\n\n**The randomness** seems to come from the location of the \"apex\" of each square-based pyramid and the order in which the four face colours are applied.\n\n**The rules** are the additional structure that stays the same between each generation. This might be things like the spacing between the pyramids, how close the apex can get to the edge of each square and that each face colour must appears exactly once on every pyramid.\n\n**My modifications** to this will be to allow the user to specify two sets of colour inputs, one set of neutral colours and one set of accent colours. Each pyramid will get three neutral sides and one accent side. \n\n## Keep It Simple, Stupid\n\nI've used R to plot polygons quite a few times before but usually in the context of something like adding a credible region around a function estimate or to show the outline of a geographic region. In both cases that's a either a single or small number of polygons where each has very many sides. What I need here is the exact opposite of that: a large number of polygons, each with a small number of sides (three to b e exact). \n\nBefore worrying about any of that though, there are a few parameters that I can set up-front, for example I can set a colour scheme that is aligned with my usual styling.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(zvplot)\nneutrals = c(zv_black, zv_white, zv_light_grey, zv_mid_grey)\naccents = c(zv_navy, zv_orange, zv_fuchia, zv_blue)\n```\n:::\n\n\nLet's start with the smallest example possible where I will be able to tell that everything is working as it should, a 2x3 grid.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn_rows = 2\nn_cols = 3\n```\n:::\n\n\nTo make this easier on myself I'm going to start off just trying to generate the squares that will form the base of each pyramid. To make finding coordinates slightly easier, I'll use a coordinate system where each square is 1 units. That will also make the parameter controlling the gap between pyramids easier to interpret.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngap_size = 0.1\n```\n:::\n\n\nI will be using `{ggplot2}` to make the plot, so I'll need to organise the coordinates of my polygon corners into a data frame. As a first step, I'll making a data frame that indexes and describes each of the squares I will need to plot. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nn_squares <- n_rows * n_cols\nsquare_id <- seq_len(n_squares)\nrow_num <- rep(1:n_rows, each = n_cols)\ncol_num <- rep(1:n_cols, times = n_rows)\nsquares <- data.frame(id = square_id, row_num, col_num)\nsquares\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  id row_num col_num\n1  1       1       1\n2  2       1       2\n3  3       1       3\n4  4       2       1\n5  5       2       2\n6  6       2       3\n```\n\n\n:::\n:::\n\n\nI can then add in the coordinates of each corner as new columns \n\n\n::: {.cell}\n\n```{.r .cell-code}\nsquares$x_min <- (1 + gap_size) * (squares$col_num - 1) + gap_size\nsquares$y_min <- (1 + gap_size) * (squares$row_num - 1) + gap_size\nsquares$x_max <- squares$x_min + 1\nsquares$y_max <- squares$y_min + 1\n  \nsquares\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  id row_num col_num x_min y_min x_max y_max\n1  1       1       1   0.1   0.1   1.1   1.1\n2  2       1       2   1.2   0.1   2.2   1.1\n3  3       1       3   2.3   0.1   3.3   1.1\n4  4       2       1   0.1   1.2   1.1   2.2\n5  5       2       2   1.2   1.2   2.2   2.2\n6  6       2       3   2.3   1.2   3.3   2.2\n```\n\n\n:::\n:::\n\n\nLooking at the [examples](https://ggplot2.tidyverse.org/reference/geom_polygon.html#ref-examples) from the `geom_poly()` documentation, I'll need the x- and y-coordinates for each vertex of every square in two separate vectors and an id vector that links each vertex (row) to it's specific polygon. As with `polygon()` in base R, it seems like polygons should be specified anti-clockwise.\n\n\nAfter a bit of head scratching, the most natural (but probably not most efficient) approach to me would be to interleave the bottom-left, bottom-right, top-right and top-left coordinates of each square that we just generated. The `{vctrs}` package has a helpful function to do this, which works for two or more vector-like objects of the same type. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(vctrs)\nvec_interleave(as.character(1:5), letters[1:5])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"1\" \"a\" \"2\" \"b\" \"3\" \"c\" \"4\" \"d\" \"5\" \"e\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nvec_interleave(as.character(1:5), letters[1:5], LETTERS[1:5])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"1\" \"a\" \"A\" \"2\" \"b\" \"B\" \"3\" \"c\" \"C\" \"4\" \"d\" \"D\" \"5\" \"e\" \"E\"\n```\n\n\n:::\n:::\n\n\nTaking care to specify the coordinates in the right order, we can construct a dataframe that contains all the information needed to create the simplified plot.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nid <- rep(squares$id, each = 4)\nx <- vec_interleave(squares$x_min, squares$x_max, squares$x_max, squares$x_min)\ny <- vec_interleave(squares$y_min, squares$y_min, squares$y_max, squares$y_max)\nvalue <- sample(x = c(neutrals, accents), size = n_squares)\nvalue <- rep(value, each = 4)\n\nplotting <- data.frame(id, x, y, value)\nhead(plotting)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  id   x   y   value\n1  1 0.1 0.1 #3D52D5\n2  1 1.1 0.1 #3D52D5\n3  1 1.1 1.1 #3D52D5\n4  1 0.1 1.1 #3D52D5\n5  2 1.2 0.1 #202020\n6  2 2.2 0.1 #202020\n```\n\n\n:::\n:::\n\n\nThat is all the up-front work done, we should now have everything we need to get our minimal working example up and running. The code to create the plot itself is remarkably simple. \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(ggplot2)\n\nggplot(plotting, aes(x = x, y = y)) +\n  geom_polygon(aes(group = id), fill = value) +\n  coord_equal() +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){fig-align='center' width=672}\n:::\n:::\n\n\n## Add a little more complexity\n\nIt's great that the simple square version works but it's not particularly exciting. Let's add in the second random aspect, the location of the apex or peak of each pyramid. To do this I'll add the x- and y-coordinates of that peak as a column in the `squares` data frame. \n\nWhen generating peak locations, I could locate them uniformly at random over the unit square. One issue with this approach is that it might cause ugly realisations where the peak is very close to one of the edges. There are lots of ways to avoid this but I'll keep it simple again and add a buffer zone that keeps the peak away from the edges. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nbuffer = 0.1 \n\nsquares$peak_x <- runif(\n  n = n_squares,\n  min = squares$x_min + buffer,\n  max = squares$x_max - buffer)\n\nsquares$peak_y <- runif(\n  n = n_squares,\n  min = squares$y_min + buffer,\n  max = squares$y_max - buffer)\n\nsquares\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  id row_num col_num x_min y_min x_max y_max    peak_x    peak_y\n1  1       1       1   0.1   0.1   1.1   1.1 0.4442918 0.3409578\n2  2       1       2   1.2   0.1   2.2   1.1 1.7946610 0.2581493\n3  3       1       3   2.3   0.1   3.3   1.1 3.0101058 0.6435676\n4  4       2       1   0.1   1.2   1.1   2.2 0.7543079 1.4341315\n5  5       2       2   1.2   1.2   2.2   2.2 1.9005211 1.5990998\n6  6       2       3   2.3   1.2   3.3   2.2 2.8278091 1.5572086\n```\n\n\n:::\n:::\n\n\nOur logic and variables are all in place to make the more complicated pyramid plot. It's exactly the same idea as before but with 24 triangles rather than 6 squares. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nid <- rep(1:(n_squares * 4), each = 3)\nx <- vec_interleave(squares$x_min, squares$peak_x, squares$x_min,\n                    squares$x_min, squares$peak_x, squares$x_max,\n                    squares$x_max, squares$x_max, squares$peak_x,\n                    squares$x_max, squares$x_min, squares$peak_x)\ny <- vec_interleave(squares$y_min, squares$peak_y, squares$y_max,\n                    squares$y_max, squares$peak_y, squares$y_max,\n                    squares$y_max, squares$y_min, squares$peak_y,\n                    squares$y_min, squares$y_min, squares$peak_y)\nvalue <- c()\nfor (i in 1:n_squares) {\n  colours <- c(sample(neutrals, 3), sample(accents, 1)) # pick colours\n  colours <- sample(colours, 4)                         # shuffle\n  value <- c(value, colours)                            # record\n}\nvalue <- rep(value, each = 3) # colour value for every vertex of every triangle\n\nplotting <- data.frame(id, x, y, value)\nhead(plotting)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  id         x         y   value\n1  1 0.1000000 0.1000000 #EEEEEE\n2  1 0.4442918 0.3409578 #EEEEEE\n3  1 0.1000000 1.1000000 #EEEEEE\n4  2 0.1000000 1.1000000 #003E74\n5  2 0.4442918 0.3409578 #003E74\n6  2 1.1000000 1.1000000 #003E74\n```\n\n\n:::\n:::\n\n\nSince we set everything up in the same way, we can use the same simple code to plot our pyramids as we did for the squares. \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(plotting, aes(x = x, y = y)) +\n  geom_polygon(aes(group = id), fill = value) +\n  coord_equal() +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-13-1.png){fig-align='center' width=672}\n:::\n:::\n\n\n\n## Make it a function \n\nOkay, we have made one version of the artwork, but the joy of generative art is\nbeing able to easily get many realisations of the same artwork and to experiment\nwith different parameter values. \n\nWe can make that a lot easier to do by consolidating the code above into a function. \n\n\n::: {.cell}\n\n```{.r .cell-code}\npyramids <- function(n_rows = 5, n_cols = 10, gap_size = 0.1, buffer = 0.1, neutrals = NULL, accents = NULL){\n  \n  # set palette if not defined by the user \n  if (is.null(neutrals)) { \n    neutrals <- c(\"#202020\", \"#FAFAFA\", \"#EEEEEE\", \"#555555\")\n  }\n  if (is.null(accents)) {\n    accents <- c(\"#003E74\", \"#E87800\", \"#C81E87\", \"#3D52D5\")\n  }\n\n  # define square bases of pyramids\n  n_squares <- n_rows * n_cols\n  square_id <- seq_len(n_squares)\n  row_num <- rep(1:n_rows, each = n_cols)\n  col_num <- rep(1:n_cols, times = n_rows)\n  squares <- data.frame(id = square_id, row_num, col_num)\n\n  # add columns for coordinates\n  squares$x_min <- (1 + gap_size) * (squares$col_num - 1) + gap_size\n  squares$y_min <- (1 + gap_size) * (squares$row_num - 1) + gap_size\n  squares$x_max <- squares$x_min + 1\n  squares$y_max <- squares$y_min + 1\n  squares$peak_x <- runif(n_squares, squares$x_min + buffer, squares$x_max - buffer)\n  squares$peak_y <- runif(n_squares, squares$y_min + buffer, squares$y_max - buffer)\n\n  # create dataframe of polygons\n  id <- rep(x = 1:(n_squares * 4), each = 3)\n  x <- vec_interleave(squares$x_min, squares$peak_x, squares$x_min,\n                      squares$x_min, squares$peak_x, squares$x_max,\n                      squares$x_max, squares$x_max, squares$peak_x,\n                      squares$x_max, squares$x_min, squares$peak_x)\n  y <- vec_interleave(squares$y_min, squares$peak_y, squares$y_max,\n                      squares$y_max, squares$peak_y, squares$y_max,\n                      squares$y_max, squares$y_min, squares$peak_y,\n                      squares$y_min, squares$y_min, squares$peak_y)\n  value <- c()\n  for (i in 1:n_squares) {\n    colours <- c(sample(neutrals, 3), sample(accents, 1)) # pick colours\n    colours <- sample(colours, 4)                         # shuffle\n    value <- c(value, colours)                            #record\n  }\n  value <- rep(value, each = 3) # colour value for each vertex of every triangle\n  \n  plotting <- data.frame(id, x, y, value)\n  \n  # return plot\n  ggplot(plotting, aes(x = x, y = y)) +\n    geom_polygon(aes(group = id), fill = value) +\n    coord_equal() +\n    theme_void()\n}\n```\n:::\n\n\nThis lets us check that when we run the function multiple times we get different realisations. \n\n\n::: {.cell layout-ncol=\"3\" layout-align=\"center\"}\n\n```{.r .cell-code}\npyramids(n_rows = 3, n_cols = 3)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-15-1.png){fig-align='center' width=672}\n:::\n\n```{.r .cell-code}\npyramids(n_rows = 3, n_cols = 3)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-15-2.png){fig-align='center' width=672}\n:::\n\n```{.r .cell-code}\npyramids(n_rows = 3, n_cols = 3)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-15-3.png){fig-align='center' width=672}\n:::\n:::\n\n\nAnd when we set the same seed, we should be able to recreate a specific version of the artwork. \n\n\n::: {.cell layout-ncol=\"2\" layout-align=\"center\"}\n\n```{.r .cell-code}\nset.seed(1234)\npyramids(n_rows = 3, n_cols = 3)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-1.png){fig-align='center' width=672}\n:::\n\n```{.r .cell-code}\nset.seed(1234)\npyramids(n_rows = 3, n_cols = 3)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-2.png){fig-align='center' width=672}\n:::\n:::\n\n\nThe really fun part is exploring new parameter combinations. Can you figure out which settings I used below?\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-17-1.png){fig-align='center' width=672}\n:::\n:::\n\n\n## Try it yourself\n\nIf you would like to make your own artwork in this style, you can either copy the code I've provided above. Alternatively, you can get started faster by using the  packaged versions of the `pyramids()` function from `{zvplot}` - there's a function for the simpler squares design too!\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndevtools::install_github(\"zakvarty/zvplot\")\n```\n:::\n\n::: {.cell layout-ncol=\"2\" layout-align=\"center\"}\n\n```{.r .cell-code}\nsquares(n_rows = 12, n_cols = 22)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-19-1.png){fig-align='center' width=672}\n:::\n\n```{.r .cell-code}\npyramids(n_rows = 2, n_cols = 2)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-19-2.png){fig-align='center' width=672}\n:::\n:::\n\n::: {.cell}\n\n:::\n\n## Session Information \n\n\n::: {.cell}\n::: {.cell-output-display}\n**R version 4.3.3 (2024-02-29)**\n\n**Platform:** x86_64-apple-darwin20 (64-bit) \n\n**locale:**\nen_US.UTF-8||en_US.UTF-8||en_US.UTF-8||C||en_US.UTF-8||en_US.UTF-8\n\n**attached base packages:** \n_stats_, _graphics_, _grDevices_, _utils_, _datasets_, _methods_ and _base_\n\n**other attached packages:** \n_ggplot2(v.3.5.1)_, _vctrs(v.0.6.5)_ and _zvplot(v.0.0.0.9000)_\n\n**loaded via a namespace (and not attached):** \n_cli(v.3.6.3)_, _knitr(v.1.45)_, _rlang(v.1.1.4)_, _xfun(v.0.43)_, _showtextdb(v.3.0)_, _sysfonts(v.0.8.9)_, _generics(v.0.1.3)_, _jsonlite(v.1.8.8)_, _labeling(v.0.4.3)_, _glue(v.1.8.0)_, _colorspace(v.2.1-1)_, _htmltools(v.0.5.8.1)_, _scales(v.1.3.0)_, _fansi(v.1.0.6)_, _rmarkdown(v.2.26)_, _pander(v.0.6.5)_, _grid(v.4.3.3)_, _evaluate(v.0.23)_, _munsell(v.0.5.1)_, _tibble(v.3.2.1)_, _fastmap(v.1.1.1)_, _yaml(v.2.3.8)_, _lifecycle(v.1.0.4)_, _compiler(v.4.3.3)_, _dplyr(v.1.1.4)_, _Rcpp(v.1.0.12)_, _htmlwidgets(v.1.6.4)_, _pkgconfig(v.2.0.3)_, _rstudioapi(v.0.16.0)_, _farver(v.2.1.2)_, _digest(v.0.6.35)_, _R6(v.2.5.1)_, _tidyselect(v.1.2.1)_, _utf8(v.1.2.4)_, _showtext(v.0.9-7)_, _pillar(v.1.9.0)_, _magrittr(v.2.0.3)_, _withr(v.3.0.1)_, _tools(v.4.3.3)_ and _gtable(v.0.3.5)_\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}