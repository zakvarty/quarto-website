{
  "hash": "2e0ab2217db328dcf60a5ef3efd222fb",
  "result": {
    "markdown": "---\ntitle: \"Packaging your R code\"\ndescription: |\n    A minimal tutorial to guide you as you make your first (or hundredth) R package. \ndate: \"2023-01-19\"\ncategories:\n  - R\n  - data science\n  - tutorial\ncode-fold: false\nimage: horst-amazing-function.png\nimage-alt: Drawing of two people, the first proundly displays a screen full of code while saying  “Behold an Amazing Function!”. The second person looks a bit scared and replies  “I would rather not behold...”. \nimage-cap: \"Illustration by Allison Horst\"\ndraft: false\nfreeze: true\nappendix-style: plain #(default, plain, none)\nbibliography: ../library.bib\n---\n\n::: {.cell}\n\n:::\n\n\n## Introduction \n\nIn this tutorial will guide you through the creation your first R package using the `{usethis}` and `{testthat}` packages. \n\nWe'll walk through the steps of setting up a new R package, adding functions and documentation, and creating tests to ensure your package is reliable and easy to use. Whether you're a seasoned R programmer or just getting started, this tutorial will provide you with the tools you need to create your own R package and share your work with others. \n\n\n## What is a package \n\nAn R package is a collection of R functions, data, and documentation that can be easily shared with and installed by others. \n\nPackages let you extending the functionality of the base R system, and are a fundamental unit of reproducible research. They can be created by anyone, and are easily distributable to others through the CRAN or GitHub. \n\nThe packages you create can be imported and used across multiple R scripts, making them an ideal way to share and use functions and data across projects. They can also be a good way to organize and structure your code, making it easier to test, document and maintain.\n\nIn this session I hope to convince you that if you can write an R function, you can write an R package. \n\n\n## 20:80 Principle\n\nProgramming and package development are huge topics. In this session we will not even cover  20% of everything there is to know. However, by focusing on the most important and the most common aspects of package development we will rapidly get a minimal package up and running. \n\nThese basics will cover ~80% of everything you ever need to do during package development. \nResources that were used to develop this tutorial, and which will support that last ~20%, are listed below. \n\n- [Hilary Parker blog post](https://hilaryparker.com/2014/04/29/writing-an-r-package-from-scratch/)\n\n- [Karl Broman primer](https://kbroman.org/pkg_primer/)\n\n- [Shannon Pileggi blog post](https://www.pipinghotdata.com/posts/2020-10-25-your-first-r-package-in-1-hour/)\n\n- [R packages](https://r-pkgs.org/whole-game.html) by Wickham and Bryan (Ch 2)\n\n- [Writing R extensions](https://cran.r-project.org/doc/manuals/R-exts.html) CRAN\n\n\n![Artwork by Ailson Horst](images/horst-R-over-time.png) \n\n\n## Tools to build a minimal R package \n\nYou will need: \n\n- R and Rstudio\n- `{devtools}`\n- `{usethis}`\n- `{testthat}`\n- `{roxygen2}`\n\nThis collection of software and R packages makes it easy to create, develop, document, test, check and share the packages you create. \n\n:::{.callout-note}\nFor the \"hardcore\" folks you can do all of this by hand, but it is an absolute pain. These tools were developed for a reason. \n:::\n\n## Create a template directory\n\nOnce per package\n\n\n::: {.cell filename='Console'}\n\n```{.r .cell-code}\nusethis::create_package(path = \"~/path/to_your_package/packageName\")\n```\n:::\n\n\nThis should be: \n\n- In your home directory, near where your other projects live;\n- __Not__ in an existing project, package or git repo;\n- __Not__ your R library where your packages are installed.\n\nYou can find out where your R packages are installed using `.libpaths()`. This is where `install.packages()` saves packages and where `library()` looks for them by default. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n.libPaths()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"/Users/zakvarty/R_libraries/4.2/cran\"                          \n[2] \"/Users/zakvarty/R_libraries/4.2/github\"                        \n[3] \"/Users/zakvarty/R_libraries/4.2/personal\"                      \n[4] \"/Library/Frameworks/R.framework/Versions/4.2/Resources/library\"\n```\n:::\n:::\n\n\nNote that yours will probably only return one entry. I've set things up to keep my R packages separated according to where they came from and so that they save to the CRAN folder by default, because this is where I get most of my packages.\n\n## What to call your package? \nNaming things in hard. \n\nAim for something short, speakable. Snake, camel and pascal case are all acceptable, but aim for simplicity. \n\nSince packages group code, the package name should describe the group in some way.\n\n  - Personal: `zvtools`, `broman`, `ralph`\n  - Colours: `rColourBrewer`, `PrettyCols`, `wesanderson`\n  - Data/Analysis type: `lubridate`, `sp`, `spatstat`, `ismev`\n\nI'll follow the inspiration of `{ismev}` and name my minimal package `eds`, after the Effective Data Science module. \n\n\n::: {.cell filename='Console'}\n\n```{.r .cell-code}\nusethis::create_package(path = \"~/Work/teaching/2022_data_science/eds\")\n```\n:::\n\n\nThis will \n\n1. Create a new R project at the specified path, \n2. Creates a template package within that project directory,\n3. Opens the project in a new RStudio session. \n\n\nIt will also output something like the following in the console:\n\n\n::: {.cell filename='Console'}\n\n```{.r .cell-code}\n✔ Creating '/Users/zakvarty/Work/teaching/2022_data_science/eds/'\n✔ Setting active project to '/Users/zakvarty/Work/teaching/2022_data_science/eds'\n✔ Creating 'R/'\n✔ Writing 'DESCRIPTION'Package: eds\nTitle: What the Package Does (One Line, Title Case)\nVersion: 0.0.0.9000\nAuthors@R (parsed):\n    * First Last <first.last@example.com> [aut, cre] (YOUR-ORCID-ID)\nDescription: What the package does (one paragraph).\nLicense: `use_mit_license()`, `use_gpl3_license()` or friends to\n    pick a license\nEncoding: UTF-8\nRoxygen: list(markdown = TRUE)\nRoxygenNote: 7.2.3\n✔ Writing 'NAMESPACE'\n✔ Writing 'eds.Rproj'\n✔ Adding '^eds\\\\.Rproj$' to '.Rbuildignore'\n✔ Adding '.Rproj.user' to '.gitignore'\n✔ Adding '^\\\\.Rproj\\\\.user$' to '.Rbuildignore'\n✔ Opening '/Users/zakvarty/Work/teaching/2022_data_science/eds/' in new RStudio session\n✔ Setting active project to '<no active project>'\n> usethis::create_package(path = \"~/Work/teaching/2022_data_science/eds\")\n✔ Setting active project to '/Users/zakvarty/Work/teaching/2022_data_science/eds'Package: eds\nTitle: What the Package Does (One Line, Title Case)\nVersion: 0.0.0.9000\nAuthors@R (parsed):\n    * First Last <first.last@example.com> [aut, cre] (YOUR-ORCID-ID)\nDescription: What the package does (one paragraph).\nLicense: `use_mit_license()`, `use_gpl3_license()` or friends to\n    pick a license\nEncoding: UTF-8\nRoxygen: list(markdown = TRUE)\nRoxygenNote: 7.2.3\n```\n:::\n\n\n\nIf we now look in the \"files\" pane, we will see that this template is very different from what we recommended for a general project. Before we get familiar with the structure of a package directory, let's first check our package with `devtools::check()`. This function forms a key part of the package development workflow and does several things. \n\n- Updates documentation for the package and its contents\n- Builds the package\n- Checks the structure and content of the built package \n- Returns errors, warnings and notes to guide your next steps. \n\nYou should check your package often during development. It takes a bit of time but it is much easier to correct a few points at a time than to diagnose why a huge package is not building. \n\nLet's take that advice and perform our first check. \n\n\n::: {.cell filename='Console'}\n\n```{.r .cell-code}\ndevtools::check()\n```\n:::\n\n\nWe will see a lot of output as the function works its way through over 50 different checks. Finally, the output ends with only one warning, telling us that we have not specified a (standard) license for our project within the DESCRIPTION file. \n\n\n::: {.cell filename='Console'}\n\n```{.r .cell-code}\n...\n── R CMD check results ───────────────────────────────────── eds 0.0.0.9000 ────\nDuration: 5.3s\n\n❯ checking DESCRIPTION meta-information ... WARNING\n  Non-standard license specification:\n    `use_mit_license()`, `use_gpl3_license()` or friends to pick a\n    license\n  Standardizable: FALSE\n\n0 errors ✔ | 1 warning ✖ | 0 notes ✔\n```\n:::\n\n\nThe license file specifies how others may use our code. We will use the permissive [MIT license](https://choosealicense.com/licenses/mit/), which we will add using another function from `{usethis}`. There are similar helper functions to add other licenses, which you can investigate further at [choosealicense.com](https://choosealicense.com/)\n\nThe `{usethis}` helper function will add a markdown and plain text version of the license to our directory and reference these in the DESCRIPTION. \n\n\n::: {.cell filename='Console'}\n\n```{.r .cell-code}\nusethis::use_mit_license(copyright_holder = \"Zak Varty\")\n```\n:::\n\n::: {.cell filename='Console'}\n\n```{.r .cell-code}\n✔ Setting active project to '/Users/zakvarty/Work/teaching/2022_data_science/eds'\n✔ Setting License field in DESCRIPTION to 'MIT + file LICENSE'\n✔ Writing 'LICENSE'\n✔ Writing 'LICENSE.md'\n✔ Adding '^LICENSE\\\\.md$' to '.Rbuildignore'\n```\n:::\n\n\nOur DESCRIPTION file should now look something like this. \n\n\n::: {.cell filename='DESCRIPTION'}\n\n```{.r .cell-code}\nPackage: eds\nTitle: What the Package Does (One Line, Title Case)\nVersion: 0.0.0.9000\nAuthors@R: \n    person(\"First\", \"Last\", , \"first.last@example.com\", role = c(\"aut\", \"cre\"),\n           comment = c(ORCID = \"YOUR-ORCID-ID\"))\nDescription: What the package does (one paragraph).\nLicense: MIT + file LICENSE\nEncoding: UTF-8\nRoxygen: list(markdown = TRUE)\nRoxygenNote: 7.2.3\n```\n:::\n\n\nWhile we are here we can fill out a few additional details. Where the template used argument order to define a `person()`, I have named these explicitly and removed the ORCID field. \n\nThe package `Title` should be short and in title case, while the package `Description` can be more detailed (a single paragraph) and split over multiple lines. Anything beyond the first line should be indented with four spaces (_note:_ four spaces != 1 tab).\n\n\n::: {.cell filename='DESCRIPTION'}\n\n```{.r .cell-code}\nPackage: eds\nTitle: Helper Functions for Effective Data Science 2022-23\nVersion: 0.0.0.9000\nAuthors@R: \n    person(\n    given = c(\"Zak\",\"D\"),\n    family = \"Varty\",\n    email = \"z.varty@imperial.ac.uk\",\n    role = c(\"aut\", \"cre\"))\nDescription: A minimal example R package created during the first lives session \n    of Effective Data Science 2022-23. This countains a simple function to \n    calculate a moving average.\nLicense: MIT + file LICENSE\nEncoding: UTF-8\nRoxygen: list(markdown = TRUE)\nRoxygenNote: 7.2.3\n```\n:::\n\n\nLet's now check the package again and see that this has resolved our issues \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndevtools::check()\n```\n:::\n\n::: {.cell filename='Console'}\n\n```{.r .cell-code}\n...\n✔  checking loading without being on the library search path ...\n─  checking examples ... NONE\n✔  checking for non-standard things in the check directory\n✔  checking for detritus in the temp directory\n   \n   \n── R CMD check results ─────────────────────────────────────────── eds 0.0.0.9000 ────\nDuration: 5.5s\n\n0 errors ✔ | 0 warnings ✔ | 0 notes ✔\n```\n:::\n\n\nFantastic! Our package has no errors, warnings or notes. \n\n## Adding a first function \n\nThe first function we will add to the package is the helper function I wrote to left- and right-pad a vector with NAs. \n\n\n::: {.cell}\n\n```{.r .cell-code}\npad_with_NAs <- function(x, n_left, n_right){\n  c(rep(NA, n_left), x, rep(NA, n_right))\n}\n```\n:::\n\n\nTo add this function to `eds`, we save it within the `R/` directory. Until your package becomes large, it is good form to save each function in its own R file, named after the function. If the package becomes large, you can then think about refactoring your code to have one script for each family or group of functions. \n\nWe can create `R/pad_with_NAs.R` manually, or with a helper function from `{usethis}`. The helper function is useful because it will either open an existing R file or create one if it does not yet exist. \n\n\n::: {.cell filename='Console'}\n\n```{.r .cell-code}\nusethis::use_r(\"pad_with_NAs\")\n#• Modify 'R/pad_with_NAs.R'\n#• Call `use_test()` to create a matching test file\n```\n:::\n\n\nWe can then paste our function definition into this file and save it. \n\n\n::: {.cell filename='R/pad_with_NAs.R'}\n\n```{.r .cell-code}\npad_with_NAs <- function(x, n_left, n_right){\n  c(rep(NA, n_left), x, rep(NA, n_right))\n}\n```\n:::\n\n\n##  Try it out\nTo try out our padding function, we need to make it available in our current R session. One way we could do this is to call `source(R/pad_with_NAs.R)`. This doesn't match with our experience of loading a package though - it would make `pad_with_NAs()` appear in our global environment pane. \n\nInstead, we can load all functions from the package using `load_all()`. This simulates the process of building, installing and loading `{eds}`, but is much faster than actually doing so. This speed difference becomes more and more beneficial as your package grows, allowing you to get an accurate sense of how users will experience your package even when you have functions that depend on each other or depend on functions from other packages.\n\n\n::: {.cell filename='Console'}\n\n```{.r .cell-code}\ndevtools::load_all()\n#ℹ Loading eds\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npad_with_NAs(x = 1:5, n_left = 2, n_right = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA NA  1  2  3  4  5 NA\n```\n:::\n:::\n\n\n## Adding Documentation \n\nIt would be great if we had handy pop-ups to explain our function arguments and help pages to explain what our function does. We can add these using {roxygen2}. This package allows you to write markdown-like comments above function definitions that are automatically converted into documentation files in the `man/` directory. \n\nTo add skeleton documentation, go to the menu and select Code > Insert Roxygen Skeleton. (This can also be done using the keyboard shortcut on that menu button when your cursor is inside the curly braces of the function.) \n\nNow our function padding function file should look something like this: \n\n\n::: {.cell filename='R/pad_with_NAs.R'}\n\n```{.r .cell-code}\n#' Title\n#'\n#' @param x \n#' @param n_left \n#' @param n_right \n#'\n#' @return\n#' @export\n#'\n#' @examples\npad_with_NAs <- function(x, n_left, n_right){\n  c(rep(NA, n_left), x, rep(NA, n_right))\n}\n```\n:::\n\n\nFilling out the relevant fields, we get something like this. \n\n\n::: {.cell filename='pad_with_NAs.R'}\n\n```{.r .cell-code}\n#' Add NAs to a vector\n#'\n#' @param x Vector to which NAs will be added.\n#' @param n_left Number of NAs to add before x.\n#' @param n_right Number of NAs to add after x.\n#'\n#' @return A vector containing x with the requested number of NA values before and after.\n#'\n#' @export\n#' @examples\n#' pad_with_NAs(1:5, n_left = 0, n_right = 3)\n#' pad_with_NAs(c(\"spider\", \"mouse\", \"cat\", \"dog\"), n_left = 1, n_right = 2)\n#'\npad_with_NAs <- function(x, n_left, n_right){\n  c(rep(NA, n_left), x, rep(NA, n_right))\n}\n```\n:::\n\n\nThe final step is to save these changes and then convert the comments to documentation using `document()`. \n\n\n::: {.cell filename='Console'}\n\n```{.r .cell-code}\ndevtools::document()\n# ℹ Updating eds documentation\n# ℹ Loading eds\n# Writing pad_with_NAs.Rd\n```\n:::\n\n\nThis will allow you to preview the help file for `pad_with_NAs()`. I say preview here, rather than view because the documentation really only gets made when you build the package (which also adds things like links between help files and a package index). This is what the \"Rendering development documentation ...\"\" message is trying to remind you.  \n\n\n::: {.cell filename='Console'}\n\n```{.r .cell-code}\n?pad_with_NAs\n# ℹ Rendering development documentation for \"pad_with_NAs\"\n```\n:::\n\n\n\n## Install your package \n\nNow that we have a minimum viable package with a single function, let's install the eds package. We do this using `devtools::install()`. \n\n\n::: {.cell filename='Console'}\n\n```{.r .cell-code}\n?devtools::install()\n```\n:::\n\n\nWe can now load and use `{eds}` just like any other package. \n\n\n::: {.cell filename='Console'}\n\n```{.r .cell-code}\nlibrary(eds)\nanimals <- c(\"spider\", \"mouse\",\"cat\")\npad_with_NAs(animals, n_left = 1,n_right = 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA       \"spider\" \"mouse\"  \"cat\"   \n```\n:::\n:::\n\n### Aside on setting installation path\n\nIf, like me, you want to install this to a non-default location then you can do this using `withr::with_libpaths()`. \n\nI would like to install this to my sub-folder for personal R packages, which is the third element of my `.libPaths` vector. \n\n\n::: {.cell filename='Console'}\n\n```{.r .cell-code}\n.libPaths()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"/Users/zakvarty/R_libraries/4.2/cran\"                          \n[2] \"/Users/zakvarty/R_libraries/4.2/github\"                        \n[3] \"/Users/zakvarty/R_libraries/4.2/personal\"                      \n[4] \"/Library/Frameworks/R.framework/Versions/4.2/Resources/library\"\n```\n:::\n:::\n\n\nI can do this by using `{withr}` to execute the same code but with my library paths temporarily replaced by only a single path, pointing to the personal packages sub-folder.\n\n\n::: {.cell filename='Console'}\n\n```{.r .cell-code}\nwithr::with_libpaths(new = .libPaths()[3], code = devtools::install())\n```\n:::\n\n\nThis is a bit of a handful to type repeatedly, so I've made a wrapper function for it in my eds package: `eds::install_local()`.\n\n\n## Functions with dependencies \n\n### Within package dependencies \n\nThe excellent thing about having a functions in a package is that they are all loaded together and don't clutter the workspace. \n\nI created `pad_with_NAs()` as a helper function for `rolling_average()`. Whenever I loaded `rolling_average()` using `src()`, I had to remember to also source the padding function. Putting both functions in a package saves this worry. It also keeps my working environment focused on the problem I am solving (the data I want to smooth) rather than the tools I am using to solve that problem (functions and their helpers). \n\n### Between package dependencies \nWe've seen that functions within a package recognise each other and that we can make functions within our package available to users using the `@export` Roxygen tag. (It did this by adding `export(pad_with_NAs)` to the NAMESPACE file. Check if you don't believe me.)\n\nWhat happens if we want to use another package's functions in our package? We have three options, depending how many functions we want to use and how often we use them. \n\n\n\n 1. Run `usethis::use_package(\"package_name\")` to declare a dependency in the DESCRIPTION file. Then use the `::` notation to clearly specify the namespace (package) of the function you want to use. (I've been doing this same thing above to make it clear to you that some function are from `devtools` and others are from `withr`.)\n\n 2. In the Roxygen section of your function, use `#' @importFrom pkg fun1 fun2` - if you prefer this over using `::`. This can be useful if you use a couple of functions frequently to keep your code shorter and easier to read.\n\n 3.  In the Roxygen section of your function, `#' @import pkg` - this imports all functions from a package and should be used very sparingly because it makes your package bulkier and increases the chance of namespace conflicts (where there is a function of the same name in two loaded packages). \n \n:::{callout-note}\nIf you are submitting your package to CRAN you need to delcalre all _ALL_ other packages your code depends on. This includes the packages that come as standard with R (other than `{base}`), for example `{stats}`, `{MASS}`, and `{graphics}`. \n:::\n\n### Example imports \n\n\n::: {.cell filename='Console'}\n\n```{.r .cell-code}\nusethis::use_package(\"stats\")\n```\n:::\n\n::: {.cell filename='R/rnorm_rounded.R'}\n\n```{.r .cell-code}\n#' Simulate rounded Gaussian random variates\n#'\n#' @param n Number of observations. If length(n) > 1, the length is taken to be the number required.\n#' @param mu Vector of means.\n#' @param sigma Vector of standard deviations.\n#' @param digits Integer indicating the number of decimal places to be used in rounding. Negative values are used to round to a power of ten, so for example `digits = -2` rounds to the nearest hundred. (See 'Details' of `base::round()`).\n#'\n#' @return Vector of Gaussian random variates, rounded to to specified number of decimal places.\n#' @export\n#'\n#' @examples\n#' rnorm_rounded(n = 10)\nrnorm_rounded <- function(n, mu = 0, sigma = 1, digits = 0){ \n  raw_values <- stats::rnorm(n, mean = mu, sd = sigma)\n  rounded_values <- base::round(raw_values, digits)\n  return(rounded_values)\n}\n```\n:::\n\n\nWe do not need to explicitly declare that `round()` is from base, or include in in a list of imported functions.\n\n\n::: {.cell filename='R/rnorm_rounded.R'}\n\n```{.r .cell-code}\n#' Simulate rounded Gaussian random variates\n#'\n#' @param n Number of observations. If length(n) > 1, the length is taken to be the number required.\n#' @param mu Vector of means.\n#' @param sigma Vector of standard deviations.\n#' @param digits Integer indicating the number of decimal places to be used in rounding. Negative values are used to round to a power of ten, so for example `digits = -2` rounds to the nearest hundred. (See 'Details' of `base::round()`).\n#'\n#' @return Vector of Gaussian random variates, rounded to to specified number of decimal places.\n#' \n#' @importFrom stats rnorm\n#' @export\n#\"\n#' @examples\n#' rnorm_rounded(n = 10)\nrnorm_rounded <- function(n, mu = 0, sigma = 1, digits = 0){ \n  raw_values <- rnorm(n, mean = mu, sd = sigma)\n  rounded_values <- round(raw_values, digits)\n  return(rounded_values)\n}\n```\n:::\n\n\nImporting the entire stats package would be overkill when we use only one function.\n\n\n::: {.cell filename='R/rnorm_rounded.R'}\n\n```{.r .cell-code}\n#' Simulate rounded Gaussian random variates\n#'\n#' @param n Number of observations. If length(n) > 1, the length is taken to be the number required.\n#' @param mu Vector of means.\n#' @param sigma Vector of standard deviations.\n#' @param digits Integer indicating the number of decimal places to be used in rounding. Negative values are used to round to a power of ten, so for example `digits = -2` rounds to the nearest hundred. (See 'Details' of `base::round()`).\n#'\n#' @return Vector of Gaussian random variates, rounded to to specified number of decimal places.\n#' \n#' @import stats\n#' @export\n#\"\n#' @examples\n#' rnorm_rounded(n = 10)\nrnorm_rounded <- function(n, mu = 0, sigma = 1, digits = 0){ \n  raw_values <- rnorm(n, mean = mu, sd = sigma)\n  rounded_values <- round(raw_values, digits)\n  return(rounded_values)\n}\n```\n:::\n\n\n### An import exception \n\nAn exception to the import procedure is the pipe from `{magrittr}`\n\nYou may want to import this to pipe within your function definitions, but having `magritr::'%>%'` in your code looks a right mess and defeats the readability benefits of piping. \n\nInstead, we have to take two steps.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nusethis::use_pipe()  # Creates R/utils-pipe.R and adds magrittr to DESCRIPTION\ndevtools::document() # Adds the pipe to your package's NAMESPACE\n```\n:::\n\n\n## Adding Tests\n\nWe can also add tests to the functions within our package. These tests will stay in a new directory called `tests/` and will be run each time the package is built. This helps us to ensure that they currently work as we expect and that we do not break them when making alterations in the future.\n\nTo write and keep track of these tests, we will use `{testthat}`. To get started we will use the helper function `usethis::use_testthat()` to:\n\n- create `⁠tests/testthat`\n- create `tests/testthat.R`\n- add `{testthat}` to the Suggests field of our package.\n\nThis needs to be done only once per package.\n\n\n::: {.cell filename='Console'}\n\n```{.r .cell-code}\nusethis::use_testthat()\n# ✔ Adding 'testthat' to Suggests field in DESCRIPTION\n# ✔ Setting Config/testthat/edition field in DESCRIPTION to '3'\n# ✔ Creating 'tests/testthat/'\n# ✔ Writing 'tests/testthat.R'\n# • Call `use_test()` to initialize a basic test file and open it for editing.\n```\n:::\n\n\nEach of our files of tests will live in the tests/testthat subdirectory in a file named after the function. We can create this file of tests by running `usethis::use_test()` while we have any of our package functions open. This will either open or create the relevant text file for us to edit or populate.\n\nThis needs to be done (at least) once for each function that we want to write tests for. Let's focus on writing tests for `pad_with_NAs()`. \n\nWith `R/pad_with_NAs.R` open, run `usethis::use_test()` to create and open a file to store the tests. Note that the naming convention here is different to our previous convention.\n\n\n::: {.cell filename='Console'}\n\n```{.r .cell-code}\nusethis::use_test()\n# ✔ Writing 'tests/testthat/test-pad_with_NAs.R'\n# • Modify 'tests/testthat/test-pad_with_NAs.R'\n```\n:::\n\n\nThis will have a dummy test included by default. \n\n\n::: {.cell filename='tests/testthat/test-pad_with-NAs.R'}\n\n```{.r .cell-code}\ntest_that(\"multiplication works\", {\n  expect_equal(2 * 2, 4)\n})\n```\n:::\n\n\nLet's change this to match one of our examples and add another test to match the other example. To try out these tests as you write them, you'll want to attach `{testthat}` to the current R session and make your package function available with `load_all()`. \n\n\n::: {.cell filename='Console'}\n\n```{.r .cell-code}\nlibrary(testthat)\ndevtools::load_all()\n# ℹ Loading eds\n```\n:::\n\n\nIf you then try running the dummy test you should get something like: \n\n\n::: {.cell filename='tests/testthat/test-pad_with-NAs.R'}\n\n```{.r .cell-code}\ntest_that(\"multiplication works\", {\n  expect_equal(2 * 2, 4)\n})\n# Test passed 😀\n```\n:::\n\n\nWe can replace this by some simple checks that the funciton behaves as expected when given examples we wrote in the documentation and when we pad with zero NAs. \n\n\n::: {.cell filename='tests/testthat/test-pad_with-NAs.R'}\n\n```{.r .cell-code}\ntest_that(\"padding by 0 works\", {\n  expect_equal(pad_with_NAs(x = 1:3, n_left = 1, n_right = 0), c(NA, 1, 2, 3))\n  expect_equal(pad_with_NAs(x = 1:3, n_left = 0, n_right = 1), c(1, 2, 3, NA))\n})\n\ntest_that(\"examples work\", {\n  expect_equal(\n    object = pad_with_NAs(1:5, n_left = 0, n_right = 3), \n    expected = c(1:5, NA, NA, NA))\n  expect_equal(\n    object = pad_with_NAs(c(\"spider\", \"mouse\", \"cat\", \"dog\"), n_left = 1, n_right = 2),\n    expected = c(NA, \"spider\", \"mouse\", \"cat\", \"dog\", NA)\n  )\n})\n```\n:::\n\n\nWe can run these tests individually, as we did before, or we can run all test in the file using the `testthat::test_file()`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntestthat::test_file(\"tests/testthat/test-pad_with_NAs.R\")\n\n# [ FAIL 1 | WARN 0 | SKIP 0 | PASS 3 ]\n#\n# ── Failure (test-pad_with_NAs.R:10): examples work ─────────────────────────────\n# pad_with_NAs(...) (`actual`) not equal to \n# c(NA, \"spider\", \"mouse\", \"cat\", \"dog\", NA) (`expected`).\n#\n# `actual[4:7]`:   \"cat\" \"dog\" NA NA\n# `expected[4:6]`: \"cat\" \"dog\" NA   \n#\n# [ FAIL 1 | WARN 0 | SKIP 0 | PASS 3 ]\n```\n:::\n\n\nFrom the test output, we can see that three of the tests are passing but one is failing. Using the additional output, we can figure out that I forgot the second `NA` in the test of the string example. Let's add that back in. \n\n\n::: {.cell filename='tests/testthat/test-pad_with-NAs.R'}\n\n```{.r .cell-code}\ntest_that(\"padding by 0 works\", {\n  expect_equal(pad_with_NAs(x = 1:3, n_left = 1, n_right = 0), c(NA, 1, 2, 3))\n  expect_equal(pad_with_NAs(x = 1:3, n_left = 0, n_right = 1), c(1, 2, 3, NA))\n})\n\ntest_that(\"examples work\", {\n  expect_equal(\n    object = pad_with_NAs(1:5, n_left = 0, n_right = 3), \n    expected = c(1:5, NA, NA, NA))\n  expect_equal(\n    object = pad_with_NAs(c(\"spider\", \"mouse\", \"cat\", \"dog\"), n_left = 1, n_right = 2),\n    expected = c(NA, \"spider\", \"mouse\", \"cat\", \"dog\", NA, NA)\n  )\n})\n```\n:::\n\n\nWe can also add some input checks to the function, in case the user tries to do something unexpected. We'll add input checks to cover two cases where the user tries to: \n\n- use negative indexing to pad _inwards_ with NAs;\n- pad an object that is not a vector. \n\nTo do this we will use the `stopifnot()` function. This is a useful shorthand to `stop()` function execution and return an error message based on a logical statement. For more detailed control of the error message or for less serious failings, which require only a `warning()` or a `message()`. Learn more about these in the Advanced R [conditions chapter](https://adv-r.hadley.nz/conditions.html).\n\n\n::: {.cell filename='R/pad_with_NAs.R'}\n\n```{.r .cell-code}\n#' Add NAs to a vector\n#'\n#' @param x Vector to which NAs will be added.\n#' @param n_left Number of NAs to add before x.\n#' @param n_right Number of NAs to add after x.\n#'\n#' @return A vector containing x with the requested number of NA values before and after.\n#'\n#' @export\n#' @examples\n#' pad_with_NAs(1:5, n_left = 0, n_right = 3)\n#' pad_with_NAs(c(\"spider\", \"mouse\", \"cat\", \"dog\"), n_left = 1, n_right = 2)\n#'\npad_with_NAs <- function(x, n_left, n_right){\n  # Input checks\n  stopifnot(n_left >= 0)\n  stopifnot(n_right >= 0)\n  stopifnot(class(x) %in% c(\"character\", \"complex\", \"integer\", \"logical\", \"numeric\", \"factor\"))\n\n  # Function Body\n  c(rep(NA, n_left), x, rep(NA, n_right))\n}\n```\n:::\n\n\n\nWe can then add additional tests to confirm that we get errors, warnings or messages where we expect them. As our test file grows, we might want to organise our tests according to their purpose. \n\n\n::: {.cell filename='tests/testthat/test-pad_with-NAs.R'}\n\n```{.r .cell-code}\n# Typical Behaviour\n\ntest_that(\"examples work\", {\n  expect_equal(\n    object = pad_with_NAs(1:5, n_left = 0, n_right = 3),\n    expected = c(1:5, NA, NA, NA))\n  expect_equal(\n    object = pad_with_NAs(c(\"spider\", \"mouse\", \"cat\", \"dog\"), n_left = 1, n_right = 2),\n    expected = c(NA, \"spider\", \"mouse\", \"cat\", \"dog\", NA, NA)\n  )\n})\n\n# Edge Cases\n\ntest_that(\"padding by 0 works\", {\n  expect_equal(pad_with_NAs(x = 1:3, n_left = 1, n_right = 0), c(NA, 1, 2, 3))\n  expect_equal(pad_with_NAs(x = 1:3, n_left = 0, n_right = 1), c(1, 2, 3, NA))\n})\n\n# Malformed Inputs\n\ntest_that(\"negative padding produces error\", {\n  expect_error(pad_with_NAs(x = 1:5, n_left = -1, n_right = 1))\n  expect_error(pad_with_NAs(x = 1:5, n_left = 1, n_right = -1))\n})\n\ntest_that(\"giving non-vector x produces error\", {\n  matrix_input <- diag(1:4)\n  list_input <- x = list(1:5, \"cat\")\n\n  expect_error(pad_with_NAs(x = matrix_input, n_left = 1, n_right = 1))\n  expect_error(pad_with_NAs(x = list_input, n_left = 1, n_right = 1))\n})\n```\n:::\n\n\nWe can continue to run test files individually, but they will all be run when we call `devtools::check()`.\n\n\n::: {.cell filename='Console'}\n\n```{.r .cell-code}\ntestthat::test_file(\"tests/testthat/test-pad_with_NAs.R\")\n# [ FAIL 0 | WARN 0 | SKIP 0 | PASS 8 ]\n```\n:::\n\n\n## Wrapping up \n\nTo wrap up let's run one last check and install the package. \n\n\n::: {.cell filename='Console'}\n\n```{.r .cell-code}\ndevtools::check()\n# ─ R CMD check results ─────────────────────────────────── eds 0.0.0.9000 ────\n# Duration: 12.1s\n#\n# 0 errors ✔ | 0 warnings ✔ | 0 notes ✔\n```\n:::\n\n\nCongratulations, you've created your first R package!\n\nYou should now have a solid understanding of how to set up a new R package, add functions and documentation by using `{usethis}` and `{devtools}`. You also know how to use `{testthat}` and `{roxygen22}` to create tests to ensure your package is reliable and easy to use.\n\nYou should now be able to create your own R package and might want to consider using [git](https://r-pkgs.org/whole-game.html#use_git) to track its development and [sharing it with others on Github](https://r-pkgs.org/whole-game.html#use_github). \n\nRemember, creating an R package is an iterative process, and it may take several rounds of testing and editing before you are satisfied with the final product. But with a little patience and persistence, you'll be able to create a package that you and others can use with confidence. \n\n\n## Follow up Tasks \n\n- Add input checks and tests for my rolling_mean function.\n- Add your own function for finding the geometric mean of a vector.\n- Add a readme file for your package, using  `usethis::use_readme_rmd()` and the relevant section of the [R packages book](https://r-pkgs.org/whole-game.html#use_readme_rmd) for guidance.\n\n-->\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}