{
  "hash": "75a30e2a2e54f0378b80fee374e3808e",
  "result": {
    "markdown": "---\ntitle: \"Data Wrangling\"\ndescription: |\n    Get your data ducks in a line using base R and the tidyverse. \ndate: \"2023-01-06\"\ncategories:\n  - data science\n  - data wrangling\n  - tutorial\ncode-fold: false\nimage: horst-wrangle-monsters.jpg\nimage-alt: Two happy looking round fuzzy monsters, each holding a similarly shaped wrench with the word “wrangle” on it. Between their tools is held up a rectangular data table labeled “TIDY.” \nimage-cap: \"Illustration from the Openscapes blog Tidy Data for reproducibility, efficiency, and collaboration by Julia Lowndes and Allison Horst\"\ndraft: false\nfreeze: true\nappendix-style: plain #(default, plain, none)\nbibliography: ../library.bib\n---\n\n\n\n## What is Data Wrangling?\n\n::: medium_right\n<img style = \"border-radius: 10%;\" src=\"horst-wrangle-monsters.jpg\" alt=\"Two happy looking round fuzzy monsters, each holding a similarly shaped wrench with the word “wrangle” on it. Between their tools is held up a rectangular data table labeled “TIDY.”\">\n:::\n\nOkay, so you've got some data. Great start! \n\nYou might have had it handed to you by a collaborator, [requested it via an API](https://www.zakvarty.com/blog/2022-12-14-apis-and-httr/) or [scraped it from the raw html of a webpage](https://www.zakvarty.com/blog/2022-12-01-rvest/). In the worst case scenario, you're an _actual_ scientist (not just a _data_ one) and you spent the last several months of your life painstakingly measuring flower petals or car parts. Now we really want to do something useful with that data. \n\nWe've seen already how you can load the data into R and pivot between wider and longer formats, but that probably isn't enough to satisfy your curisity. You want to be able to view your data, manipulate and subset it, create new variables from exisiting ones and cross-reference your dataset with others. All of these are things possible in R and are known under various collective names including data manipulation, data munging and data wrangling. \n\nI've decided to use the term data wranging here. That's because data manipulation sounds boring a.f. and data munging is both unpleasant to say and makes me imagine we are squelching through some sort of information swamp. \n\nIn what follows I'll give a fly-by tour of tools for data wrangling in R, showing some examples along the way. I'll focus on some of the most common and useful operations and link out to some more extensive guides for wrangling your data in R, that you can refer back to as you need them. \n\n\n## Example Data Sets \n\nTo demonstrate some standard skills we will use some standard datasets that come built into any R installation. These are the `penguins` data set from `{palmerpenguins}` and the `mtcars` data set. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(palmerpenguins)\npengins <- palmerpenguins::penguins\ncars <- datasets::mtcars\n```\n:::\n\n\n\n## Viewing Your Data \n\n### `View()`\nThe `View()` function can be used to crease a spreadsheet-like view of your data. In RStudio this will open as a new tab. \n\n`View()` will work for any \"matrix-like\" R object, such as a tibble, data frame, vector or matrix. Note the capital letter - the function is called `View()`, not `view()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nView(penguins)\n```\n:::\n\n\n![Screenshot of RStduio files pane, containg a spreadsheet view of the palmer penguins data set.](view-penguins-screenshot.png){width=\"60%\"}\n\n### `head()`\n\nFor large data sets, you might not want (or be able to) view it all at once. You can then use `head()` to view the first few rows. The integer argument `n` specifies the number of rows you would like to return. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(x = pengins, n = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 8\n  species island    bill_length_mm bill_depth_mm flipper_l…¹ body_…² sex    year\n  <fct>   <fct>              <dbl>         <dbl>       <int>   <int> <fct> <int>\n1 Adelie  Torgersen           39.1          18.7         181    3750 male   2007\n2 Adelie  Torgersen           39.5          17.4         186    3800 fema…  2007\n3 Adelie  Torgersen           40.3          18           195    3250 fema…  2007\n# … with abbreviated variable names ¹​flipper_length_mm, ²​body_mass_g\n```\n:::\n:::\n\n\n\n### `str()`\n\nAn alternative way to view the a large data set, or one with a complicated format is to examine its structure with `str()`. This is a useful way to inspect the structure of list-like objects, particularly when they've got a nested structure.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(penguins)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntibble [344 × 8] (S3: tbl_df/tbl/data.frame)\n $ species          : Factor w/ 3 levels \"Adelie\",\"Chinstrap\",..: 1 1 1 1 1 1 1 1 1 1 ...\n $ island           : Factor w/ 3 levels \"Biscoe\",\"Dream\",..: 3 3 3 3 3 3 3 3 3 3 ...\n $ bill_length_mm   : num [1:344] 39.1 39.5 40.3 NA 36.7 39.3 38.9 39.2 34.1 42 ...\n $ bill_depth_mm    : num [1:344] 18.7 17.4 18 NA 19.3 20.6 17.8 19.6 18.1 20.2 ...\n $ flipper_length_mm: int [1:344] 181 186 195 NA 193 190 181 195 193 190 ...\n $ body_mass_g      : int [1:344] 3750 3800 3250 NA 3450 3650 3625 4675 3475 4250 ...\n $ sex              : Factor w/ 2 levels \"female\",\"male\": 2 1 1 NA 1 2 1 2 NA NA ...\n $ year             : int [1:344] 2007 2007 2007 2007 2007 2007 2007 2007 2007 2007 ...\n```\n:::\n:::\n\n\n### `names()`\nFinally, if you just want to access the variable names you can do so with the `names()` function from base R. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(penguins)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"species\"           \"island\"            \"bill_length_mm\"   \n[4] \"bill_depth_mm\"     \"flipper_length_mm\" \"body_mass_g\"      \n[7] \"sex\"               \"year\"             \n```\n:::\n:::\n\n\nSimilarly, you can explicitly access the row and column names of a data frame or tibble using `colnames()` or `rownames()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(cars)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"mpg\"  \"cyl\"  \"disp\" \"hp\"   \"drat\" \"wt\"   \"qsec\" \"vs\"   \"am\"   \"gear\"\n[11] \"carb\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nrownames(cars)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"Mazda RX4\"           \"Mazda RX4 Wag\"       \"Datsun 710\"         \n [4] \"Hornet 4 Drive\"      \"Hornet Sportabout\"   \"Valiant\"            \n [7] \"Duster 360\"          \"Merc 240D\"           \"Merc 230\"           \n[10] \"Merc 280\"            \"Merc 280C\"           \"Merc 450SE\"         \n[13] \"Merc 450SL\"          \"Merc 450SLC\"         \"Cadillac Fleetwood\" \n[16] \"Lincoln Continental\" \"Chrysler Imperial\"   \"Fiat 128\"           \n[19] \"Honda Civic\"         \"Toyota Corolla\"      \"Toyota Corona\"      \n[22] \"Dodge Challenger\"    \"AMC Javelin\"         \"Camaro Z28\"         \n[25] \"Pontiac Firebird\"    \"Fiat X1-9\"           \"Porsche 914-2\"      \n[28] \"Lotus Europa\"        \"Ford Pantera L\"      \"Ferrari Dino\"       \n[31] \"Maserati Bora\"       \"Volvo 142E\"         \n```\n:::\n:::\n\nIn the `cars` data, the car model are stored as the row names. This doesn't really jive with our idea of tidy data - we'll see how to fix that shortly. \n\n## Renaming Variables \n\n### `colnames()`\n\nThe function `colnames()` can be used to set as well as to retrieve column names.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncars_renamed <- cars \ncolnames(cars_renamed)[1] <- \"miles_per_gallon\"\ncolnames(cars_renamed)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"miles_per_gallon\" \"cyl\"              \"disp\"             \"hp\"              \n [5] \"drat\"             \"wt\"               \"qsec\"             \"vs\"              \n [9] \"am\"               \"gear\"             \"carb\"            \n```\n:::\n:::\n\n\n### `dplyr::rename()`\nWe can also use functions from `{dplyr}` to rename columns. Let's alter the second column name.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'dplyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n:::\n\n```{.r .cell-code}\ncars_renamed <- rename(.data = cars_renamed, cylinders = cyl)\ncolnames(cars_renamed)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"miles_per_gallon\" \"cylinders\"        \"disp\"             \"hp\"              \n [5] \"drat\"             \"wt\"               \"qsec\"             \"vs\"              \n [9] \"am\"               \"gear\"             \"carb\"            \n```\n:::\n:::\n\n\nThis could be done as part of a pipe, if we were making many alterations. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ncars_renamed <- cars_renamed %>% \n  rename(displacement = disp) %>% \n  rename(horse_power = hp) %>% \n  rename(rear_axel_ratio = drat)\n\ncolnames(cars_renamed)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"miles_per_gallon\" \"cylinders\"        \"displacement\"     \"horse_power\"     \n [5] \"rear_axel_ratio\"  \"wt\"               \"qsec\"             \"vs\"              \n [9] \"am\"               \"gear\"             \"carb\"            \n```\n:::\n:::\n\n\nWhen using the dplyr function you have to remember the format `new_name = old_name`. This matches the format used to create a data frame or tibble, but is the opposite order to the python function of the same name and often catches people out. \n\nIn the section (#creating-new-variables) on creating new variables, we will see an alternative way of doing this by copying the column and then deleting the original. \n\n## Subsetting\n\n### Base R \n\nIn base R you can extract rows, columns and combinations thereof using index notation. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# First row\npenguins[1, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 8\n  species island    bill_length_mm bill_depth_mm flipper_l…¹ body_…² sex    year\n  <fct>   <fct>              <dbl>         <dbl>       <int>   <int> <fct> <int>\n1 Adelie  Torgersen           39.1          18.7         181    3750 male   2007\n# … with abbreviated variable names ¹​flipper_length_mm, ²​body_mass_g\n```\n:::\n\n```{.r .cell-code}\n# First Column \npenguins[ , 1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 344 × 1\n   species\n   <fct>  \n 1 Adelie \n 2 Adelie \n 3 Adelie \n 4 Adelie \n 5 Adelie \n 6 Adelie \n 7 Adelie \n 8 Adelie \n 9 Adelie \n10 Adelie \n# … with 334 more rows\n```\n:::\n\n```{.r .cell-code}\n# Rows 2-3 of columns 1, 2 and 4\npenguins[2:3, c(1, 2, 4)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 3\n  species island    bill_depth_mm\n  <fct>   <fct>             <dbl>\n1 Adelie  Torgersen          17.4\n2 Adelie  Torgersen          18  \n```\n:::\n:::\n\n\nUsing negative indexing you can remove rows or columns \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Drop all but first row\npenguins[-(2:344), ]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 8\n  species island    bill_length_mm bill_depth_mm flipper_l…¹ body_…² sex    year\n  <fct>   <fct>              <dbl>         <dbl>       <int>   <int> <fct> <int>\n1 Adelie  Torgersen           39.1          18.7         181    3750 male   2007\n# … with abbreviated variable names ¹​flipper_length_mm, ²​body_mass_g\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Drop all but first column \npenguins[ , -(2:8)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 344 × 1\n   species\n   <fct>  \n 1 Adelie \n 2 Adelie \n 3 Adelie \n 4 Adelie \n 5 Adelie \n 6 Adelie \n 7 Adelie \n 8 Adelie \n 9 Adelie \n10 Adelie \n# … with 334 more rows\n```\n:::\n:::\n\n\nYou can also select rows or columns by their names. This can be done using the bracket syntax (`[ ]`) or the dollar syntax (`$`). \n\n\n::: {.cell}\n\n```{.r .cell-code}\npengins[ , \"species\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 344 × 1\n   species\n   <fct>  \n 1 Adelie \n 2 Adelie \n 3 Adelie \n 4 Adelie \n 5 Adelie \n 6 Adelie \n 7 Adelie \n 8 Adelie \n 9 Adelie \n10 Adelie \n# … with 334 more rows\n```\n:::\n\n```{.r .cell-code}\npenguins$species\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  [1] Adelie    Adelie    Adelie    Adelie    Adelie    Adelie    Adelie   \n  [8] Adelie    Adelie    Adelie    Adelie    Adelie    Adelie    Adelie   \n [15] Adelie    Adelie    Adelie    Adelie    Adelie    Adelie    Adelie   \n [22] Adelie    Adelie    Adelie    Adelie    Adelie    Adelie    Adelie   \n [29] Adelie    Adelie    Adelie    Adelie    Adelie    Adelie    Adelie   \n [36] Adelie    Adelie    Adelie    Adelie    Adelie    Adelie    Adelie   \n [43] Adelie    Adelie    Adelie    Adelie    Adelie    Adelie    Adelie   \n [50] Adelie    Adelie    Adelie    Adelie    Adelie    Adelie    Adelie   \n [57] Adelie    Adelie    Adelie    Adelie    Adelie    Adelie    Adelie   \n [64] Adelie    Adelie    Adelie    Adelie    Adelie    Adelie    Adelie   \n [71] Adelie    Adelie    Adelie    Adelie    Adelie    Adelie    Adelie   \n [78] Adelie    Adelie    Adelie    Adelie    Adelie    Adelie    Adelie   \n [85] Adelie    Adelie    Adelie    Adelie    Adelie    Adelie    Adelie   \n [92] Adelie    Adelie    Adelie    Adelie    Adelie    Adelie    Adelie   \n [99] Adelie    Adelie    Adelie    Adelie    Adelie    Adelie    Adelie   \n[106] Adelie    Adelie    Adelie    Adelie    Adelie    Adelie    Adelie   \n[113] Adelie    Adelie    Adelie    Adelie    Adelie    Adelie    Adelie   \n[120] Adelie    Adelie    Adelie    Adelie    Adelie    Adelie    Adelie   \n[127] Adelie    Adelie    Adelie    Adelie    Adelie    Adelie    Adelie   \n[134] Adelie    Adelie    Adelie    Adelie    Adelie    Adelie    Adelie   \n[141] Adelie    Adelie    Adelie    Adelie    Adelie    Adelie    Adelie   \n[148] Adelie    Adelie    Adelie    Adelie    Adelie    Gentoo    Gentoo   \n[155] Gentoo    Gentoo    Gentoo    Gentoo    Gentoo    Gentoo    Gentoo   \n[162] Gentoo    Gentoo    Gentoo    Gentoo    Gentoo    Gentoo    Gentoo   \n[169] Gentoo    Gentoo    Gentoo    Gentoo    Gentoo    Gentoo    Gentoo   \n[176] Gentoo    Gentoo    Gentoo    Gentoo    Gentoo    Gentoo    Gentoo   \n[183] Gentoo    Gentoo    Gentoo    Gentoo    Gentoo    Gentoo    Gentoo   \n[190] Gentoo    Gentoo    Gentoo    Gentoo    Gentoo    Gentoo    Gentoo   \n[197] Gentoo    Gentoo    Gentoo    Gentoo    Gentoo    Gentoo    Gentoo   \n[204] Gentoo    Gentoo    Gentoo    Gentoo    Gentoo    Gentoo    Gentoo   \n[211] Gentoo    Gentoo    Gentoo    Gentoo    Gentoo    Gentoo    Gentoo   \n[218] Gentoo    Gentoo    Gentoo    Gentoo    Gentoo    Gentoo    Gentoo   \n[225] Gentoo    Gentoo    Gentoo    Gentoo    Gentoo    Gentoo    Gentoo   \n[232] Gentoo    Gentoo    Gentoo    Gentoo    Gentoo    Gentoo    Gentoo   \n[239] Gentoo    Gentoo    Gentoo    Gentoo    Gentoo    Gentoo    Gentoo   \n[246] Gentoo    Gentoo    Gentoo    Gentoo    Gentoo    Gentoo    Gentoo   \n[253] Gentoo    Gentoo    Gentoo    Gentoo    Gentoo    Gentoo    Gentoo   \n[260] Gentoo    Gentoo    Gentoo    Gentoo    Gentoo    Gentoo    Gentoo   \n[267] Gentoo    Gentoo    Gentoo    Gentoo    Gentoo    Gentoo    Gentoo   \n[274] Gentoo    Gentoo    Gentoo    Chinstrap Chinstrap Chinstrap Chinstrap\n[281] Chinstrap Chinstrap Chinstrap Chinstrap Chinstrap Chinstrap Chinstrap\n[288] Chinstrap Chinstrap Chinstrap Chinstrap Chinstrap Chinstrap Chinstrap\n[295] Chinstrap Chinstrap Chinstrap Chinstrap Chinstrap Chinstrap Chinstrap\n[302] Chinstrap Chinstrap Chinstrap Chinstrap Chinstrap Chinstrap Chinstrap\n[309] Chinstrap Chinstrap Chinstrap Chinstrap Chinstrap Chinstrap Chinstrap\n[316] Chinstrap Chinstrap Chinstrap Chinstrap Chinstrap Chinstrap Chinstrap\n[323] Chinstrap Chinstrap Chinstrap Chinstrap Chinstrap Chinstrap Chinstrap\n[330] Chinstrap Chinstrap Chinstrap Chinstrap Chinstrap Chinstrap Chinstrap\n[337] Chinstrap Chinstrap Chinstrap Chinstrap Chinstrap Chinstrap Chinstrap\n[344] Chinstrap\nLevels: Adelie Chinstrap Gentoo\n```\n:::\n:::\n\n\nSince `penguins` is a tibble, these return different types of object. Sub-setting a tibble with bracket syntax will return a tibble, while extracting a column using the dollar syntax returns a vector of values. \n\n### `filter()` and `select()`\n\n`{dplyr}` has two functions for subsetting, `filter()` subsets by rows and `select()` subsets by column. \n\nIn both functions you list what you would like to retain. Filter and select calls can be piped together to subset based on row and column values. \n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins %>% \n  select(species, island,body_mass_g)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 344 × 3\n   species island    body_mass_g\n   <fct>   <fct>           <int>\n 1 Adelie  Torgersen        3750\n 2 Adelie  Torgersen        3800\n 3 Adelie  Torgersen        3250\n 4 Adelie  Torgersen          NA\n 5 Adelie  Torgersen        3450\n 6 Adelie  Torgersen        3650\n 7 Adelie  Torgersen        3625\n 8 Adelie  Torgersen        4675\n 9 Adelie  Torgersen        3475\n10 Adelie  Torgersen        4250\n# … with 334 more rows\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins %>% \n  select(species, island, body_mass_g) %>% \n  filter(body_mass_g > 6000)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 3\n  species island body_mass_g\n  <fct>   <fct>        <int>\n1 Gentoo  Biscoe        6300\n2 Gentoo  Biscoe        6050\n```\n:::\n:::\n\n\nSubsetting rows can be inverted by negating the `filter()` statement.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins %>% \n  select(species, island, body_mass_g) %>% \n  filter(!(body_mass_g > 6000))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 340 × 3\n   species island    body_mass_g\n   <fct>   <fct>           <int>\n 1 Adelie  Torgersen        3750\n 2 Adelie  Torgersen        3800\n 3 Adelie  Torgersen        3250\n 4 Adelie  Torgersen        3450\n 5 Adelie  Torgersen        3650\n 6 Adelie  Torgersen        3625\n 7 Adelie  Torgersen        4675\n 8 Adelie  Torgersen        3475\n 9 Adelie  Torgersen        4250\n10 Adelie  Torgersen        3300\n# … with 330 more rows\n```\n:::\n:::\n\n\nand dropping columns can done by selecting all columns except the one(s) you want to drop.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins %>% \n  select(species, island, body_mass_g) %>% \n  filter(!(body_mass_g > 6000)) %>% \n  select(!c(species, island))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 340 × 1\n   body_mass_g\n         <int>\n 1        3750\n 2        3800\n 3        3250\n 4        3450\n 5        3650\n 6        3625\n 7        4675\n 8        3475\n 9        4250\n10        3300\n# … with 330 more rows\n```\n:::\n:::\n\n\n## Creating New Variables {#creating-new-variables}\n\n### Base R\n\nWe can create new variables in base R by assigning a vector of the correct length to a new column name.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncars_renamed$weight <- cars_renamed$wt\n```\n:::\n\n\nIf we then drop the original column from the data frame, this gives us an alternative way of renaming columns. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ncars_renamed <- cars_renamed[ ,-which(names(cars_renamed) == \"wt\")]\nhead(cars_renamed, n = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                  miles_per_gallon cylinders displacement horse_power\nMazda RX4                     21.0         6          160         110\nMazda RX4 Wag                 21.0         6          160         110\nDatsun 710                    22.8         4          108          93\nHornet 4 Drive                21.4         6          258         110\nHornet Sportabout             18.7         8          360         175\n                  rear_axel_ratio  qsec vs am gear carb weight\nMazda RX4                    3.90 16.46  0  1    4    4  2.620\nMazda RX4 Wag                3.90 17.02  0  1    4    4  2.875\nDatsun 710                   3.85 18.61  1  1    4    1  2.320\nHornet 4 Drive               3.08 19.44  1  0    3    1  3.215\nHornet Sportabout            3.15 17.02  0  0    3    2  3.440\n```\n:::\n:::\n\n\nOne thing to be aware of is that this operation does not preserve column ordering. \n\nGenerally speaking, code that relies on columns being in a specific order is fragile - it breaks easily. If possible, you should try to write your code in another way that's robust to column reordering. I've done that here when removing the `wt` column by looking up the column index as part of my code, rather than assuming it will always be the fourth column.\n\n### `dplyr::mutate()`\n\nThe function from `{dplyr}` to create new columns is `mutate()`. Let's create another column that has the car's weight in kilogrammes rather than tonnes. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ncars_renamed <- cars_renamed %>% \n  mutate(weight_kg = weight * 1000)\n\ncars_renamed %>% \n  select(miles_per_gallon, cylinders, displacement, weight, weight_kg) %>% \n  head(n = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                  miles_per_gallon cylinders displacement weight weight_kg\nMazda RX4                     21.0         6          160  2.620      2620\nMazda RX4 Wag                 21.0         6          160  2.875      2875\nDatsun 710                    22.8         4          108  2.320      2320\nHornet 4 Drive                21.4         6          258  3.215      3215\nHornet Sportabout             18.7         8          360  3.440      3440\n```\n:::\n:::\n\n\nYou can also create new columns that combine multiple other columns \n\n\n::: {.cell}\n\n```{.r .cell-code}\ncars_renamed <- cars_renamed %>% \n  mutate(cylinder_adjusted_mpg = miles_per_gallon / cylinders)\n```\n:::\n\n\n\n### `rownames_to_column()`\n\nOne useful example of adding an additional row to a data frame is to convert its row names to a column of the data fame. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncars %>% \n  mutate(model = rownames(cars_renamed)) %>% \n  select(mpg, cyl, model) %>% \n  head(n = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                   mpg cyl             model\nMazda RX4         21.0   6         Mazda RX4\nMazda RX4 Wag     21.0   6     Mazda RX4 Wag\nDatsun 710        22.8   4        Datsun 710\nHornet 4 Drive    21.4   6    Hornet 4 Drive\nHornet Sportabout 18.7   8 Hornet Sportabout\n```\n:::\n:::\n\n\nThere\\s a neat function called `rownames_to_column()` in `{tibble}` which will add this as the first column and remove the row names all in one step. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ncars %>% \n  tibble::rownames_to_column(var = \"model\") %>% \n  head(n = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n              model  mpg cyl disp  hp drat    wt  qsec vs am gear carb\n1         Mazda RX4 21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\n2     Mazda RX4 Wag 21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\n3        Datsun 710 22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\n4    Hornet 4 Drive 21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\n5 Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\n```\n:::\n:::\n\n\n### `rowids_to_column()`\n\nAnother function from `{tibble}` adds the row id of each observation as a new column. This is often useful when ordering or combining tables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncars %>% \n  tibble::rowid_to_column(var = \"row_id\") %>% \n  head(n = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  row_id  mpg cyl disp  hp drat    wt  qsec vs am gear carb\n1      1 21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\n2      2 21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\n3      3 22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\n4      4 21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\n5      5 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\n```\n:::\n:::\n\n\n## Summaries \n\nThe `summarise()` function allows you to collapse a data frame into a single row, which gives a summary statistic of your choosing. \n\nThis can be used to calculate a single summary \n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummarise(penguins, average_bill_length_mm = mean(bill_length_mm))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 1\n  average_bill_length_mm\n                   <dbl>\n1                     NA\n```\n:::\n:::\n\nSince we have missing values, we might instead want to calculate the mean of the recorded values. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummarise(penguins, average_bill_length_mm = mean(bill_length_mm, na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 1\n  average_bill_length_mm\n                   <dbl>\n1                   43.9\n```\n:::\n:::\n\n\nWe can also use `summarise()` to gather multiple summaries in a single data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbill_length_mm_summary <- penguins %>% \n  summarise(\n    mean = mean(bill_length_mm, na.rm = TRUE),\n    median = median(bill_length_mm, na.rm = TRUE),\n    min = max(bill_length_mm, na.rm = TRUE),\n    q_0 = min(bill_length_mm, na.rm = TRUE),\n    q_1 = quantile(bill_length_mm, prob = 0.25, na.rm = TRUE),\n    q_2 = median(bill_length_mm, na.rm = TRUE),\n    q_3 = quantile(bill_length_mm, prob = 0.25, na.rm = TRUE),\n    q_4 = max(bill_length_mm, na.rm = TRUE))\n\nbill_length_mm_summary\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 8\n   mean median   min   q_0   q_1   q_2   q_3   q_4\n  <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n1  43.9   44.4  59.6  32.1  39.2  44.4  39.2  59.6\n```\n:::\n:::\n\n\nIn all this isn't overly exciting. You might, rightly, wonder why you'd want to use these `summarise()` calls when we could just use the simpler base R calls directly. \n\nOne benefit is that the summarise calls ensure consistent output. However, the main advantage comes when you want to apply these summaries to distinct subgroups of the data. \n\n## Grouped Operations \n\nThe real benefit of `summarise()` comes from its combination with `group_by()`. This allows to you calculate the same summary statistics for each level of a factor with only one additional line of code. Here we're re-calculating the same set of summary statistics we just found for all penguins, but for each individual species. \n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins %>% \n  group_by(species) %>%\n  summarise(\n    mean = mean(bill_length_mm, na.rm = TRUE),\n    median = median(bill_length_mm, na.rm = TRUE),\n    min = max(bill_length_mm, na.rm = TRUE),\n    q_0 = min(bill_length_mm, na.rm = TRUE),\n    q_1 = quantile(bill_length_mm, prob = 0.25, na.rm = TRUE),\n    q_2 = median(bill_length_mm, na.rm = TRUE),\n    q_3 = quantile(bill_length_mm, prob = 0.25, na.rm = TRUE),\n    q_4 = max(bill_length_mm, na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 9\n  species    mean median   min   q_0   q_1   q_2   q_3   q_4\n  <fct>     <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n1 Adelie     38.8   38.8  46    32.1  36.8  38.8  36.8  46  \n2 Chinstrap  48.8   49.6  58    40.9  46.3  49.6  46.3  58  \n3 Gentoo     47.5   47.3  59.6  40.9  45.3  47.3  45.3  59.6\n```\n:::\n:::\n\n\nYou can group by multiple factors to calculate summaries for each distinct combination of levels within your data set. Here we group by combinations of species and the island to which they belong. \n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguin_summary_stats <- penguins %>% \n  group_by(species, island) %>%\n  summarise(\n    mean = mean(bill_length_mm, na.rm = TRUE),\n    median = median(bill_length_mm, na.rm = TRUE),\n    min = max(bill_length_mm, na.rm = TRUE),\n    q_0 = min(bill_length_mm, na.rm = TRUE),\n    q_1 = quantile(bill_length_mm, prob = 0.25, na.rm = TRUE),\n    q_2 = median(bill_length_mm, na.rm = TRUE),\n    q_3 = quantile(bill_length_mm, prob = 0.25, na.rm = TRUE),\n    q_4 = max(bill_length_mm, na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'species'. You can override using the\n`.groups` argument.\n```\n:::\n\n```{.r .cell-code}\npenguin_summary_stats\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 10\n# Groups:   species [3]\n  species   island     mean median   min   q_0   q_1   q_2   q_3   q_4\n  <fct>     <fct>     <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n1 Adelie    Biscoe     39.0   38.7  45.6  34.5  37.7  38.7  37.7  45.6\n2 Adelie    Dream      38.5   38.6  44.1  32.1  36.8  38.6  36.8  44.1\n3 Adelie    Torgersen  39.0   38.9  46    33.5  36.7  38.9  36.7  46  \n4 Chinstrap Dream      48.8   49.6  58    40.9  46.3  49.6  46.3  58  \n5 Gentoo    Biscoe     47.5   47.3  59.6  40.9  45.3  47.3  45.3  59.6\n```\n:::\n:::\n\n### Ungrouping \n\nBy default, each call to `summarise()` will undo one level of grouping. This means that our previous result was still grouped by species. \n\n(We can see this by examining the structure of the returned data frame. The first line tells us that this this is an S3 object of class \"grouped_df\", which inherits its properties from a \"tbl_df\", whose properties in turn come from \"tbl\" and \"data.frame\" objects.)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(penguin_summary_stats)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"grouped_df\" \"tbl_df\"     \"tbl\"        \"data.frame\"\n```\n:::\n:::\n\n\nSince we have grouped by two variables, R expects us to use two summaries before returning a data frame (or tibble) that is not grouped. One way to satisfy this is to use apply a second summary at the species level of grouping. \n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguin_summary_stats %>% \n  summarise_all(mean, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in mean.default(island, na.rm = TRUE): argument is not numeric or\nlogical: returning NA\n\nWarning in mean.default(island, na.rm = TRUE): argument is not numeric or\nlogical: returning NA\n\nWarning in mean.default(island, na.rm = TRUE): argument is not numeric or\nlogical: returning NA\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 10\n  species   island  mean median   min   q_0   q_1   q_2   q_3   q_4\n  <fct>      <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n1 Adelie        NA  38.8   38.7  45.2  33.4  37.0  38.7  37.0  45.2\n2 Chinstrap     NA  48.8   49.6  58    40.9  46.3  49.6  46.3  58  \n3 Gentoo        NA  47.5   47.3  59.6  40.9  45.3  47.3  45.3  59.6\n```\n:::\n:::\n\n\nHowever, we won't always want to do apply another summary. In that case, we can undo the grouping using `ungroup()`. Remembering to ungroup is a gotcha and cause of confusion when working with multiple-group summaries. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nungroup(penguin_summary_stats)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 10\n  species   island     mean median   min   q_0   q_1   q_2   q_3   q_4\n  <fct>     <fct>     <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n1 Adelie    Biscoe     39.0   38.7  45.6  34.5  37.7  38.7  37.7  45.6\n2 Adelie    Dream      38.5   38.6  44.1  32.1  36.8  38.6  36.8  44.1\n3 Adelie    Torgersen  39.0   38.9  46    33.5  36.7  38.9  36.7  46  \n4 Chinstrap Dream      48.8   49.6  58    40.9  46.3  49.6  46.3  58  \n5 Gentoo    Biscoe     47.5   47.3  59.6  40.9  45.3  47.3  45.3  59.6\n```\n:::\n:::\n\nThere's an alternative method to achieve the same thing in a single step when using `{dplyr}` versions 1.0.0 and above. This is to to set the `.groups` parameter of the `summarise()` function call, which determines the grouping of the returned data frame.\n\nThe `.groups` parameter and can take 4 possible values: \n\n- \"drop_last\": dropping the last level of grouping (The only option before v1.0.0);\n\n- \"drop\": All levels of grouping are dropped;\n\n- \"keep\": Same grouping structure as `.data`;\n\n- \"rowwise\": Each row is its own group.\n\nBy default, \"drop_last\" is used if all the results have 1 row and \"keep\" is used otherwise.\n\n\n### Reordering Factors \n\nR stored factors as integer values, which it then maps to a set of labels. Only factor levels that appear in your data will be assigned a coded integer value and the mapping between factor levels and integers will depend on the order that the labels appear in your data.\n\nThis can be annoying, particularly when your factor levels relate to properties that aren't numerical but do have an inherent ordering to them. In the example below, we have the t-shirt size of twelve people.   \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntshirts <- tibble::tibble(\n  id = 1:12, \n  size = as.factor(c(\"L\", NA, \"M\", \"S\", \"XS\", \"M\", \"XXL\", \"L\", \"XS\", \"M\", \"L\", \"S\"))\n)\n\nlevels(tshirts$size)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"L\"   \"M\"   \"S\"   \"XS\"  \"XXL\"\n```\n:::\n:::\n\nAnnoyingly, the sizes aren't in order and extra large is not included because it is not included in the sample. This leads to awkward summary tables (and plots). \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntshirts %>% group_by(size) %>% summarise(count = n())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 2\n  size  count\n  <fct> <int>\n1 L         3\n2 M         3\n3 S         2\n4 XS        2\n5 XXL       1\n6 <NA>      1\n```\n:::\n:::\n\n\nWe can fix this by creating a new variable with the factors explicitly coded in the correct order. We also need to sepecify that we should not drop empty groups as part of `group_by()`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntidy_tshirt_levels <- c(\"XS\", \"S\", \"M\", \"L\", \"XL\", \"XXL\", NA)\n\ntshirts %>% \n  mutate(size_tidy = factor(size, levels = tidy_tshirt_levels)) %>% \n  group_by(size_tidy, .drop = FALSE ) %>% \n  summarise(count = n())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 7 × 2\n  size_tidy count\n  <fct>     <int>\n1 XS            2\n2 S             2\n3 M             3\n4 L             3\n5 XL            0\n6 XXL           1\n7 <NA>          1\n```\n:::\n:::\n\n\n\n## Be Aware: Factors \n\nAs we have seen a little already, categorical variables can cause issues when wrangling and presenting data in R. All of these problems are solvable using base R techniques but the `{forcats}` package provides tools for the most common of these problems. This includes functions for changing the order of factor levels or the values with which they are associated. \n\nSome examples functions from the package include:\n\n- `fct_reorder()`: Reordering a factor by another variable.\n- `fct_infreq()`: Reordering a factor by the frequency of values.\n- `fct_relevel()`: Changing the order of a factor by hand.\n- `fct_lump()`: Collapsing the least/most frequent values of a factor into “other”.\n\nExamples of each of these can be found in the [forcats vignette](https://forcats.tidyverse.org/articles/forcats.html) or the [factors chapter]((https://r4ds.had.co.nz/factors.html)) of R for data science. \n\n## Be Aware: Strings \n\nWorking with and analysing text data is a skill unto itself. However, it is useful to be able to do some basic manipulation of character strings programatically.\n\nBecause R was developed as a statistical programming language, it is well suited to the computational and modelling aspects of working with text data but the base R string manipulation functions can be a bit unwieldy at times. \n\nThe `{stringr}` package aims to combat this by providing useful helper functions for a range of text management problems. Even when not analysing text data these can be useful, for example to remove prefixes on a lot of column names. \n\n\n::: {.cell}\n::: {.cell-output .cell-output-stderr}\n```\nWarning: `as_data_frame()` was deprecated in tibble 2.0.0.\nℹ Please use `as_tibble()` instead.\nℹ The signature and semantics have changed, see `?as_tibble`.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: The `x` argument of `as_tibble.matrix()` must have unique column names if\n`.name_repair` is omitted as of tibble 2.0.0.\nℹ Using compatibility `.name_repair`.\nℹ The deprecated feature was likely used in the tibble package.\n  Please report the issue at <\u001b]8;;https://github.com/tidyverse/tibble/issues\u0007https://github.com/tidyverse/tibble/issues\u001b]8;;\u0007>.\n```\n:::\n:::\n\n\nSuppose we wanted to keep only the text following an underscore in these column names. We could do that by using a regular expression to extract lower-case or upper-case letters which follow an underscore.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(poorly_named_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 11\n  observatio…¹   V1_A   V2_B   V3_C    V4_D    V5_E   V6_F   V7_G   V8_H    V9_I\n         <int>  <dbl>  <dbl>  <dbl>   <dbl>   <dbl>  <dbl>  <dbl>  <dbl>   <dbl>\n1            1 -0.199 -0.729  1.14   0.0205 -0.714  -1.14  0.786  -0.926 -0.740 \n2            2 -0.956 -1.71  -0.184  1.44   -1.97   -0.470 0.0393  1.42  -2.49  \n3            3  0.585 -1.06  -1.43   0.361   0.0141  0.585 1.01   -1.90  -0.0825\n4            4  0.624  1.17   0.263  1.72   -0.0808  0.707 1.93   -0.675  0.448 \n5            5  0.425 -0.190 -0.360 -0.443   0.134  -0.339 0.0577  1.21  -1.38  \n6            6  0.169  1.40   1.82  -0.999   1.14   -0.377 0.471   0.934  0.604 \n# … with 1 more variable: V10_J <dbl>, and abbreviated variable name\n#   ¹​observation_id\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstringr::str_extract(names(poorly_named_df), pattern = \"(?<=_)([a-zA-Z]+)\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"id\" \"A\"  \"B\"  \"C\"  \"D\"  \"E\"  \"F\"  \"G\"  \"H\"  \"I\"  \"J\" \n```\n:::\n:::\n\nAlternatively, can avoid using regular expressions. We can split each column name at the underscore and keep only the second part of each string. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# split column names at underscores and inspect structure of resuting object\nsplit_strings <- stringr::str_split(names(poorly_named_df), pattern = \"_\")\nstr(split_strings)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 11\n $ : chr [1:2] \"observation\" \"id\"\n $ : chr [1:2] \"V1\" \"A\"\n $ : chr [1:2] \"V2\" \"B\"\n $ : chr [1:2] \"V3\" \"C\"\n $ : chr [1:2] \"V4\" \"D\"\n $ : chr [1:2] \"V5\" \"E\"\n $ : chr [1:2] \"V6\" \"F\"\n $ : chr [1:2] \"V7\" \"G\"\n $ : chr [1:2] \"V8\" \"H\"\n $ : chr [1:2] \"V9\" \"I\"\n $ : chr [1:2] \"V10\" \"J\"\n```\n:::\n\n```{.r .cell-code}\n# keep only the second element of each character vector in the list\npurrr::map_chr(split_strings, function(x){x[2]})\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"id\" \"A\"  \"B\"  \"C\"  \"D\"  \"E\"  \"F\"  \"G\"  \"H\"  \"I\"  \"J\" \n```\n:::\n:::\n\n\nAgain, unless you plan to work extensively with text data, I would recommend that you look up such string manipulations as you need them. The [strings](https://r4ds.had.co.nz/strings.html#strings) section of R for Data Science is a useful starting point. \n\n## Be Aware: Date-Times\n\nRemember all the fuss we made about storing dates in the ISO standard format? That was because dates and times are complicated enough to work with before adding extra ambiguity.\n\n$$ \\text{YYYY} - \\text{MM} - \\text{DD}$$\nDates, times and time intervals have to reconcile two factors: the physical orbit of the Earth around the sun and the social and geopolitical mechanisms that determine how we measure and record the passing of time. This makes the history of date and time records fascinating and can make working with this type of data complicated.\n\nMoving from larger to smaller time spans: leap years alter the number of days in a year, months are of variable length (with February's length changing from year to year). If your data are measured in a place that uses daylight saving, then one day a year will be 23 hours long and another will be 25 hours long. To make things worse, the dates and the hour at which the clocks change are not uniform across countries, which might be in distinct time zones that themselves change over time.\n\nEven at the level of minutes and seconds we aren't safe - since the Earth's orbit is gradually slowing down a leap second is added approximately every 21 months. Nor are things any better when looking at longer time scales or across cultures, where we might have to account for different calendars: months are added removed and altered over time, other calendar systems still take different approaches to measuring time and using different units and origin points. \n\nWith all of these issues you have to be very careful when working with date and time data. Functions to help you with this can be found in the `{lubridate}` package, with examples in the [dates and times](https://r4ds.had.co.nz/dates-and-times.html#dates-and-times) chapter of R for data science.  \n\n<!--\n- How many days are there in a year? (365-366)\n- How many months days are there in a month? (28-31)\n- How many hours are there in a day? (23-25)\n- How many seconds are there in a minute? (60-61)\n- What calendar are you using?\n  - How many months are there in the year? \n  - When does a year begin?\n--> \n\n\n## Be Aware: Relational Data\n\nWhen the data you need are stored across two or more data frames you need to be able to cross-reference those and match up values for observational unit. This sort of data is know as relational data, and is used extensively in data science. \n\nThe variables you use to match observational units across data frames are known as _keys_. The primary key belongs to the first table and the foreign key belongs to the secondary table. There are various ways to join these data frames, depending on if you want to retain. \n\n#### Join types \n\nYou might want to keep only observational units that have key variables values in both data frames, this is known as an inner join. \n\n![Inner join diagram. Source: R for Data Science](join-inner.png)\n\nYou might instead want to keep all units from the primary table but pad with NAs where there is not a corresponding foreign key in the second table. This results in an __(outer) left-join__.\n\n![Diagram for left, right and outer joins. Source: R for Data Science](join-left-right-full.png) \n\nConversely, you might keep all units from the second table but pad with NAs where there is not a corresponding foreign key in the primary table. This is imaginatively named an __(outer) right-join__. \n\nThe final common join type is an outer join, in which all observational units from either table are retained and all missing values are padded with NAs. This is known as an __(outer) full join__.\n\n\nThings get more complicated when keys do not uniquely identify observational units in one or both tables. I'd recommend you start exploring these ideas with the [relational data]() chapter of R for Data Science. \n\n#### Why and where to learn more\n\n\nWorking with relational data is essential to getting any data science up and running out in the wilds of reality. This is because businesses and companies don't store all of their data in a huge single csv file. For one this isn't very efficient, because most cells would be empty. Secondly, it's not a very secure approach, since you can't grant partial access to the data.  That's why information is usually stored in many data frames (more generically known as tables) within one or more databases. \n\nThese data silos are created, maintained, accessed and destroyed using a relational data base management system. These management systems use code to manage and access the stored data, just like we have seen in the dplyr commands above. You might well have heard of the SQL programming language (and its many variants), which is a popular language for data base management and is the inspiration for the dplyr package and verbs. \n\nIf you'd like to learn more then there are many excellent introductory SQL books and courses, I'd recommend picking one that focuses on data analysis or data science unless you really want to dig into efficient storage and querying of databases.\n\n\n## Wrapping up \n\nWe have:\n\n- Learned how to wrangle tabular data in R with `{dplyr}`\n\n- Met the idea of relational data and `{dplyr}`'s relationship to SQL\n\n- Become aware of some tricky data types and packages that can help. \n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}